-- Object finder functions

local alife_obj = igi_helper.alife_obj

local trace_assert = igi_helper.trace_assert
local trace_dbg = igi_helper.trace_dbg

entities = {}
levels_by_distance = {}
distance_by_levels = {}
smarts_by_level = {}

function on_game_start()
	blacklist = igi_db.SectionView("map_config.ltx", "blacklist"):as_set()
	smart_blacklist = igi_db.SectionView("map_config.ltx", "smart_blacklist"):as_set()

	RegisterScriptCallback("server_entity_on_register", server_entity_on_register)
	RegisterScriptCallback("server_entity_on_unregister", server_entity_on_unregister)
	RegisterScriptCallback("actor_on_first_update", actor_on_first_update)
end

function actor_on_first_update()
	sort_levels_by_distance()
	sort_smarts_by_level()
	CreateTimeEvent("igi_finder", "fill_entities", 0, fill_entities)
end

function server_entity_on_register(se_obj)
	local section = se_obj:section_name()
	if not entities[section] then entities[section] = {} end
	entities[section][se_obj.id] = true
end

function server_entity_on_unregister(se_obj)
	local section = se_obj:section_name()
	if not entities[section] then
		return trace_dbg("unregister not registered!", section)
	end
	entities[section][se_obj.id] = nil
end

function fill_entities()
	local sim = alife()
	for i=1,65534 do
		local se_obj = sim:object(i)
		if se_obj then server_entity_on_register(se_obj) end
	end
	ResetTimeEvent("igi_finder", "fill_entities", 60)
end

------------------------------

function sort_levels_by_distance()
	local actor_level = level.name()
	levels_by_distance[0] = {[actor_level] = true}
	distance_by_levels[actor_level] = 0
	local visited = {[actor_level] = true}

	local cur_distance = 0
	local changes = true
	while changes do
		cur_distance = cur_distance + 1
		changes = false

		for start_level in pairs(levels_by_distance[cur_distance-1]) do
			local connected_levels = simulation_objects.config:r_value(
				start_level, "target_maps", 0, "")

			for con_level in connected_levels:gmatch("[^ ,]+") do
				if not visited[con_level] then
					visited[con_level] = true
					changes = true
					if not levels_by_distance[cur_distance] then
						levels_by_distance[cur_distance] = {}
					end
					levels_by_distance[cur_distance][con_level] = true
					distance_by_levels[con_level] = cur_distance
				end
			end
		end
	end
end

local function is_smart_good(smart_name, smart_level, smart_id)
	local in_blacklist = smart_blacklist[smart_name] or
		(smart_level ~= level.name() and blacklist[smart_level])
	local is_available = simulation_objects.available_by_id[smart_id]
	local is_base = simulation_objects.base_smarts[smart_name]
	return is_available and not (is_base or in_blacklist)
end

function sort_smarts_by_level()
	local sim = alife()
	local gg = game_graph()

	for name, smart in pairs(SIMBOARD.smarts_by_names) do
		local smart_level = sim:level_name(gg:vertex(smart.m_game_vertex_id):level_id())
		if is_smart_good(name, smart_level, smart.id) then
			if not smarts_by_level[smart_level] then smarts_by_level[smart_level] = {} end
			smarts_by_level[smart_level][name] = true
		end
	end
end
------------

local function object_in_world(se_obj)
	return se_obj.parent_id == 65535
end

local function object_in_npc_inventory(se_obj)
	return igi_helper.check_common_npc(se_obj.parent_id)
end

local function get_object_level_id(se_obj, gg)
	local lvl_info_obj = se_obj
	if not object_in_world(se_obj) then
		lvl_info_obj = alife_obj(se_obj.parent_id)
	end
	return gg:vertex(lvl_info_obj.m_game_vertex_id):level_id()
end

local function get_object_level(se_obj, sim, gg)
	return sim:level_name(get_object_level_id(se_obj, gg))
end

local function get_distance_bounds(str)
	str:gsub("end", tostring(#levels_by_distance))
	if not str:find(",") then str = str..","..str end
	local lower, higher = str:match("(%d+),(%d+)")
	return tonumber(lower), tonumber(higher)
end

local function check_location(se_obj, args, sim, gg)
	local obj_level = get_object_level(se_obj, sim, gg)
	if blacklist[obj_level] then return false end

	local dist = distance_by_levels[obj_level]
	local lower_bound, higher_bound = get_distance_bounds(args.search_distance)
	return dist >= lower_bound and dist <= higher_bound
end

local function enemy_to_handler(se_obj, args, sim)
	if se_obj.parent_id == 65535 then return end
	local my_faction = args.enemy_to or get_object_community(db.actor)
	local npc_faction = get_object_community(sim:object(se_obj.parent_id))
	return game_relations.is_factions_enemies(my_faction, npc_faction)
end

local function is_rat(se_squad)
	local section = se_squad and se_squad:section_name()
	return string.find(section,"tushkano") or string.find(section,"rat")
end

local function check_squad_by_args(se_squad, smart, args)
	
	if not simulation_objects.is_on_the_same_level(se_squad, smart) then
		trace_dbg("not same lvl")
		return false
	end
	
	if se_squad.current_target_id ~= smart.id then
		trace_dbg("target wrong")
		return false
	end
	
	if se_squad.current_action ~= 1 or not se_squad.stay_time then
		trace_dbg("action or stay time")
		return false
	end
	
	if args.min_num and se_squad:npc_count() < args.min_num then
		return false
	end
	
	if is_rat(se_squad) or not args.factions[se_squad.player_id] then
		trace_dbg("factions sucked")
		return false
	end
	
	if (not args.include_scripted) and se_squad:get_script_target() then
		return false
	end
	
	return true
end

local function add_squads_of_smart(smart_name, args, squads_tbl)
	local smart = SIMBOARD.smarts_by_names[smart_name]
	local smart_data = SIMBOARD.smarts[smart.id]

	for sq_id, _ in pairs(smart_data.squads) do
		local se_squad = alife_obj(sq_id)
		if check_squad_by_args(se_squad, smart_data.smrt, args) then
			squads_tbl[#squads_tbl + 1] = sq_id
		end
	end
end

function is_smart_location(val)
	if type(val) ~= "table" then return false end
	return tonumber(val[1] or "") and tonumber(val[2] or "")
end

arg_handlers = {
	only_enemies = enemy_to_handler,
}
local function check_object_by_args(se_obj, args, sim, gg)
	if not check_location(se_obj, args, sim, gg) then
		-- igi_helper.trace_dbg("location sucked")
		return false
	end

	for k, v in pairs(arg_handlers) do
		local handler = args[k] and v
		if handler then
			if not handler(se_obj, args, sim, gg) then
				-- igi_helper.trace_dbg(k.." sucked")
				return false
			end
		end
	end
	
	return true
end


local function get_objects_filtered_by_args(objects, args)
	local sim = alife()
	local gg = game_graph()
	local filtered = {}

	for _, group in pairs(objects) do
		for id in pairs(group) do
			local se_obj = sim:object(id)
			if check_object_by_args(se_obj, args, sim, gg) then
				filtered[#filtered+1] = se_obj
			end
		end
	end

	return filtered
end

function get_objects_by_args(typ, args)
	local items_pool = get_items(typ, args.endings)
	return get_objects_filtered_by_args(items_pool, args)
end

function get_items(sections, possible_endings)
	possible_endings = possible_endings or {}
	if type(sections) == "string" then
		sections = igi_db.ini_tables[sections]:as_table()
	end
	items = {}

	for _, section in pairs(sections) do
		if entities[section] then items[#items+1] = entities[section] end

		-- endings are important for artefacts (i.e. arti in box)
		for _, ending in pairs(possible_endings) do
			local with_ending = section..ending
			if entities[with_ending] then
				items[#items+1] = entities[with_ending]
			end
		end
	end

	return items
end


function get_smarts(where)
	local smart_list = {}
	local lower_bound, higher_bound = where[1], where[2]
	
	for i=lower_bound, higher_bound do
		for level in pairs(levels_by_distance[i]) do
			for smart in pairs(smarts_by_level[level] or {}) do
				smart_list[#smart_list+1] = smart
			end
		end
	end

	return smart_list
end

function get_squads_by_args(args)
	local targets = {}
	trace_dbg("finder: get squad by args", args)
	if args.factions then
		if type(args.factions) ~= "table" then
			args.factions = {args.factions}
		end
		args.factions = igi_utils.Set.from_list(args.factions)
	end

	if args.smart then
		add_squads_of_smart(args.smart, args, targets)
	else
		for _, smart_name in pairs(get_smarts(args.where)) do
			add_squads_of_smart(smart_name, args, targets)
		end
	end

	return targets
end
