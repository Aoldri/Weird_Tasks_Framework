------------------------------------------------
-- LOCALS
-- No actual grouping, these are used to lower other functions complexity
------------------------------------------------
local trace_dbg = igi_helper.trace_dbg
local trace_assert = igi_helper.trace_assert
local WorldState = igi_world_state.WorldState


local function ids_to_entities(prototype, ids)
	if prototype.amount == 'all' then
		prototype.amount = #ids
	end
	ids = igi_utils.get_random_items(ids, prototype.amount or 1)
	if not ids then return end

	prototype:bind_to_se_obj(ids[#ids])
	ids[#ids] = nil

	local new_entities = {}
	for _, id in ipairs(ids) do
		new_entities[#new_entities+1] = prototype:clone():binded_to(id)
	end
	return new_entities
end

local function unwrap_entity_amount(prototype)
	local new_entities = {}
	for _=2, prototype.amount or 1 do
		new_entities[#new_entities+1] = prototype:clone()
	end
	return new_entities
end

local function assert_has_valid_section(entity)
	local section = trace_assert(entity.section_name, "Section does not exist")
	trace_assert(ini_sys:section_exist(section), "bad section: "..section)
end

local function force_parent_online(se_obj)
	if se_obj.parent_id == 65535 then return end
	local parent = WorldState.objects[se_obj.parent_id]
	local p_clsid = parent:clsid()
	if IsStalker(parent, p_clsid)
			or IsMonster(parent, p_clsid)
			or p_clsid == clsid.online_offline_group_s
			then
		parent.force_online = true
		parent.stay_time = game.get_game_time()
	end
end

local function get_coords(str)
	trace_assert(type(str) == "string")
	local lvl, x, y, z = str:match("(.*),(.*),(.*),(.*)")
	x, y, z = tonumber(x), tonumber(y), tonumber(z)
	lvl = igi_db.LtxView("map_config.ltx").map_names[lvl]
	trace_assert(lvl, "ERROR: Can't get lvl! "..str)
	return lvl, x, y, z
end

------------------------------------------------
-- DESCRIPTION
-- Prepares description
------------------------------------------------

function get_description(entity)
	local desc = igi_description.TaskDescription.new()
	local factions = desc.factions
	local targets = desc.targets
	local locations = desc.locations

	if entity.entity_type == "squad" and entity.id then
		local se_obj = WorldState.objects[entity.id]
		factions[#factions+1] = se_obj.player_id
		locations[#locations+1] = id
	elseif entity.entity_type == "squad" then
		factions[#factions+1] = entity.faction
		locations[#locations+1] = entity.where
	elseif entity.entity_type == "item" and entity.id then
		local se_obj = WorldState.objects[entity.id]
		local parent_id = se_obj.parent_id
		local parent_npc = igi_helper.check_common_npc(parent_id) and WorldState.objects[parent_id]

		factions[#factions+1] = parent_npc and alife_character_community(parent_npc) or nil
		targets[#targets+1] = parent_npc and parent_npc:character_name() or nil
		locations[#locations+1] = entity.id
	elseif entity.entity_type == "item" then
		targets[#targets+1] = igi_db.TEXT_HEADER..entity.section_name
	end
	return desc
end

------------------------------------------------
-- SETUP FUNCTIONS
-- Prepares objects for task, rolls random dice, finds objects in world
------------------------------------------------

function setup_location(entity)
	--trace_assert(entity.where or entity.coords, "location has no info")
	if entity.coords then
		return unwrap_entity_amount(entity)
	end

	if entity.id then
		entity:bind_to_se_obj(entity.id)
		return unwrap_entity_amount(entity)
	end

	if entity.name then
		local smart = trace_assert(
			SIMBOARD.smarts_by_names[entity.name],
			"Unknown name "..entity.name)
		entity:bind_to_se_obj(smart.id)
		entity.name = nil
		return unwrap_entity_amount(entity)
	end

	local ids
	if entity.search_for == 'smart' then
		ids = igi_finder.get_smarts(entity.where)
	elseif entity.search_for == 'stash' then
		ids = igi_finder.get_stashes(args)
	else
		trace_assert(nil, "Unknown location type")
	end
	return ids_to_entities(entity, ids)
end

function setup_squad(entity)
	if entity.to_create then
		assert_has_valid_section(entity)
		return unwrap_entity_amount(entity)
	end

	local enemy_factions
	if entity.type == "mutant" then
		enemy_factions = igi_db.ini_tables["monster_types"]:as_set()
	elseif entity.type == "enemy" then
		enemy_factions = igi_helper.get_faction_enemies(character_community(db.actor))
	else
		enemy_factions = trace_assert(entity.factions, "No factions given")
	end

	local ids = igi_finder.get_squads_by_args(entity, enemy_factions)
	return ids_to_entities(entity, ids)
end

function setup_item(entity)
	if entity.to_create then
		assert_has_valid_section(entity)
		return unwrap_entity_amount(entity)
	end

	trace_assert(entity.item_list, "No item list given")
	local ids = igi_finder.get_objects_by_args(
		entity.item_list, entity)
	return ids_to_entities(entity, ids)
end

------------------------------------------------
-- CREATE FUNCTIONS
-- Called after getting a task to create/prepare actual game objects
------------------------------------------------

function create_location(entity)
	if entity.location_type == 'stash' then
		treasure_manager.set_random_stash(nil, nil, nil, entity.id)
	end
end

function create_squad(entity)
	if entity:is_binded_to_se_obj() then
		local squad = entity:get_binded_object()
		squad.stay_time = game.get_game_time()
		squad.force_online = true
		return
	end

	local smart_name = SIMBOARD.smarts[entity.where].smrt:name()
	local squad = utils_obj.create_squad(entity.section_name, smart_name)
	squad.stay_time = game.get_game_time()
	squad.force_online = true

	entity:bind_to_se_obj(squad.id)
end

function create_item(entity)
	if entity:is_binded_to_se_obj() then
		force_parent_online(entity:get_binded_object())
		return
	end

	local se_obj
	if SIMBOARD.smarts[entity.where] then -- TODO: distinction with flag
		local smart = SIMBOARD.smarts[entity.where].smrt
		local location = vector():set(
			smart.position.x,
			smart.position.y+1,
			smart.position.z)

		se_obj = alife_create(entity.section_name, location,
			smart.m_level_vertex_id, smart.m_game_vertex_id)
	elseif tonumber(entity.where) then
		local parent = WorldState.objects[entity.where]
		se_obj = alife_create_item(entity.section_name, parent)
	else
		local lvl, x, y, z = get_coords(entity.where)
		se_obj = alife_create(entity.section_name, vector():set(x,y+1,z), 0, lvl)
	end
	entity:bind_to_se_obj(se_obj.id)
end

------------------------------------------------
-- OTHER FUNCTIONS
-- Lorem ipsum dolor sit amet, consectetur adipiscing elit.
------------------------------------------------

function quest_target(entity)
	return entity.id
end

function get_completed_money(entity)
	return 3000
end

function get_completed_goodwill(entity)
	return 25
end

function get_factions(entity, task_giver_id)
	return {igi_helper.get_community_by_id(task_giver_id)}
end

function get_failed_money(entity)
	return 0
end

function get_failed_goodwill(entity)
	return -25
end

function get_basic_reward_for_status(status, entity, task_giver_id)
	local target_tbl = entity:get_target_table()
	local goodwill = igi_rewards.GoodwillReward.new()
	goodwill:set_value(target_tbl["get_"..status:lower().."_goodwill"](entity))
	goodwill:set_factions(target_tbl.get_factions(entity, task_giver_id))

	money = igi_rewards.MoneyReward.new()
	money:set(target_tbl["get_"..status:lower().."_money"](entity))

	local t = igi_rewards.RewardTable.new()
	t:add(goodwill)
	t:add(money)
	return t
end

function initialise_rewards(entity, CACHE)
	local task_giver_id = CACHE:get_task_giver_id()
	entity.reward = igi_rewards.SubtaskRewards.new()
	entity.reward:set_reward_of_status(
		igi_subtask.TASK_STATUSES.COMPLETED,
		get_basic_reward_for_status(
			igi_subtask.TASK_STATUSES.COMPLETED, entity, task_giver_id)
	)
	entity.reward:set_reward_of_status(
		igi_subtask.TASK_STATUSES.FAILED,
		get_basic_reward_for_status(
			igi_subtask.TASK_STATUSES.FAILED, entity, task_giver_id)
	)
end
