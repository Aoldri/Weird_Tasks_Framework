------------------------------------------------
-- LOCALS
-- No actual grouping, these are used to lower other functions complexity
------------------------------------------------
local trace_dbg = igi_helper.trace_dbg
local trace_assert = igi_helper.trace_assert
local WorldState = igi_world_state.WorldState

local function create_squad_data(entity)
	local section = trace_assert(entity.section_name, "Section does not exist")
	trace_assert(ini_sys:section_exist(section), section)
	local faction = ini_sys:r_string_ex(section, "faction")

	entity.faction = faction or "mutant"

	if entity.where and igi_linker.is_dependency(entity.where) then
		entity.where_link = igi_linker.Dependency.from(entity.where):get_link()
	end

	return true
end

local function fetch_squad_data(entity)
	-- important: ids, predefined name, description, target
	local enemy_factions
	if entity.type == "mutant" then
		enemy_factions = igi_db.ini_tables["monster_types"]:as_set()
	elseif entity.type == "enemy" then
		enemy_factions = igi_helper.get_faction_enemies(character_community(db.actor))
	else
		enemy_factions = entity.factions
	end
	trace_assert(enemy_factions)

	local squads = igi_finder.get_squads_by_args(entity, enemy_factions)
	trace_dbg('squads', squads)

	if entity.amount == 'all' then
		entity.amount = #squads
	end

	local ids = igi_utils.get_random_items(squads, entity.amount)
	if not ids then return end
	entity.ids = ids
	entity.section_name = "predefined_squad"

	if entity.where and igi_linker.is_dependency(entity.where) then
		entity.where_link = igi_linker.Dependency.from(entity.where):get_link()
	end

	return true
end

local function fetch_item_data(entity)
	trace_assert(entity.item_list, "No item list given")

	local objects = igi_finder.get_objects_by_args(
		entity.item_list, entity)

	if not next(objects) then
		trace_dbg("WTF: no objects", entity)
		return
	end

	local objects = igi_utils.get_random_items(objects, entity.amount)
	if not objects then return nil end

	entity.ids = {}
	for _, se_obj in pairs(objects) do
		entity.ids[#entity.ids + 1] = se_obj.id
	end

	if entity.amount == 'all' then
		entity.amount = #entity.ids
	end

	return true
end

local function find_smarts(where, amount)
	local smarts = igi_finder.get_smarts(where)
	if amount == 'all' then
		amount = #smarts
	end
	local smarts_list = igi_utils.get_random_items(smarts, amount)
	if not smarts_list then return end
	for k, smart_name in pairs(smarts_list) do
		local smart = SIMBOARD.smarts_by_names[smart_name]
		smarts_list[k] = smart.id
	end
	return smarts_list
end

local function find_stash(args)
	local stashes = igi_finder.get_stashes(args)
	return igi_utils.get_random_items(stashes, args.amount)
end

local function force_parent_online(se_obj)
	local parent_id = se_obj.parent_id
	if parent_id ~= 65535 then
		local parent = WorldState.objects[parent_id]
		local p_clsid = parent:clsid()
		if IsStalker(parent, p_clsid)
				or IsMonster(parent, p_clsid)
				or p_clsid == clsid.online_offline_group_s
				then
			parent.force_online = true
			parent.stay_time = game.get_game_time()
		end
	end
end

local function get_vector(x,y,z)
	return vector():set(x, y+1, z)
end

local function get_coords(str)
	trace_assert(type(str) == "string")
	local lvl, x, y, z = str:match("(.*),(.*),(.*),(.*)")
	x, y, z = tonumber(x), tonumber(y), tonumber(z)
	lvl = igi_db.LtxView("map_config.ltx").map_names[lvl]
	trace_assert(lvl, "ERROR: Can't get lvl! "..str)
	return lvl, x, y, z
end

local function create_item_on_smart(entity)
	local items = igi_target.EntitiesTable.new()
	local smart = SIMBOARD.smarts[entity.where].smrt
	local location = get_vector(
		smart.position.x,
		smart.position.y,
		smart.position.z)
	for i=1, entity.amount do
		local se_obj = alife_create(entity.section_name, location, 
		smart.m_level_vertex_id, smart.m_game_vertex_id)
		items:add_se_obj(entity.entity_type, entity.group_id, i, se_obj, entity)
	end
	return items
end

local function create_item_in_inventory(entity)
	local items = igi_target.EntitiesTable.new()
	local parent = WorldState.objects[entity.where]
	for i=1, entity.amount do
		local se_obj = alife_create_item(entity.section_name, parent)
		items:add_se_obj(entity.entity_type, entity.group_id, i, se_obj, entity)
	end
	return items
end

local function create_item_on_coords(entity)
	local items = igi_target.EntitiesTable.new()
	local lvl, x, y, z = get_coords(entity.where)
	local se_obj = alife_create(entity.section_name, get_vector(x,y,z), 0, lvl)
	items:add_se_obj(entity.entity_type, entity.group_id, 1, se_obj, entity)
	return items
end

local function setup_existing_items(entity)
	local items = igi_target.EntitiesTable.new()
	for i, id in pairs(entity.ids) do
		local se_obj = WorldState.objects[id]
		force_parent_online(se_obj)
		items:add_se_obj(entity.entity_type, entity.group_id, i, se_obj, entity)
	end
	return items
end

------------------------------------------------
-- DESCRIPTION
-- Prepares description
------------------------------------------------

function get_description(entity)
	local desc = igi_description.TaskDescription.new()
	local factions = desc.factions
	local targets = desc.targets
	local locations = desc.locations

	if entity.entity_type == "squad" and entity.ids then
		for _, id in pairs(entity.ids) do
			local se_obj = WorldState.objects[id]
			factions[#factions+1] = se_obj.player_id
			locations[#locations+1] = id
		end
	elseif entity.entity_type == "squad" then
		factions[#factions+1] = entity.faction
		locations[#locations+1] = entity.where
	elseif entity.entity_type == "item" and entity.ids then
		for _, id in pairs(entity.ids) do
			local se_obj = WorldState.objects[id]
			local parent_id = se_obj.parent_id
			local parent_npc = igi_helper.check_common_npc(parent_id) and WorldState.objects[parent_id]

			factions[#factions+1] = parent_npc and alife_character_community(parent_npc) or nil
			targets[#targets+1] = parent_npc and parent_npc:character_name() or nil
			locations[#locations+1] = id
		end
		return igi_models.create_DescriptionData(factions, targets, locations)
	elseif entity.entity_type == "item" then
		targets[#targets+1] = igi_db.TEXT_HEADER..entity.section_name
	end
	return desc
end

------------------------------------------------
-- SETUP FUNCTIONS
-- Prepares objects for task, rolls random dice, finds objects in world
------------------------------------------------

function setup_location(entity)
	--trace_assert(entity.where or entity.coords, "location has no info")
	if entity.coords then
		return entity
	end

	local where = entity.where
	if tonumber(where) or type(where)=="string" and igi_linker.has_dependency(where)  then
		entity.id = where
		entity.where = nil
		return entity
	end

	if igi_finder.is_smart_location(entity.where) then
		entity.smarts = find_smarts(entity.where, entity.amount or 1)
		return entity
	end

	if entity.location_type == 'stash' then
		entity.ids = find_stash(entity)
		return entity
	end

	local smart = trace_assert(SIMBOARD.smarts_by_names[where], "Unknown name "..where)
	entity.id = smart.id
	entity.where = nil
	return true
end

function setup_squad(entity)
	if entity.to_create then
		return create_squad_data(entity)
	else
		return fetch_squad_data(entity)
	end
end

function setup_smart(entity)
	if entity.smart_name then
		trace_assert(SIMBOARD.smarts_by_names[entity.smart_name],
			"Wrong smart name "..entity.smart_name)
			entity.smarts = {entity.smart_name}
	else
		local amount = entity.amount or 1
		local possible_smarts = igi_finder.get_smarts(entity.where)

		if #possible_smarts < amount then return end
		local smarts_list = igi_utils.get_random_items(possible_smarts, amount)
		local smart_names = {}
		for _, smart in pairs(smarts_list) do
			table.insert(smart_names, smart.smrt:name())
		end

		entity.smarts = smart_names
	end
	return true
end

function setup_item(entity)
	if entity.to_create then
		local section = trace_assert(entity.section_name, "Section does not exist")
		if not ini_sys:section_exist(section) then
			trace_assert(nil, "bad item section: "..(section or "nil"))
		end
		return true
	else
		return fetch_item_data(entity)
	end
end

------------------------------------------------
-- CREATE FUNCTIONS
-- Called after getting a task to create/prepare actual game objects
------------------------------------------------

function create_location(entity)
	local locations = igi_target.EntitiesTable.new()
	if entity.smarts then
		for i, id in pairs(entity.smarts) do
			local loc_data = {id = id}
			locations:add(entity.group_id, i, loc_data, entity)
		end
	elseif entity.location_type == 'stash' then
		for i, id in pairs(entity.ids) do
			treasure_manager.set_random_stash(nil, nil, nil, id)
			locations:add(entity.group_id, i, {id = id}, entity)
		end
	else
		locations:add(entity.group_id, 1, entity)
	end
	return locations
end

function create_squad(entity)
	local squads = igi_target.EntitiesTable.new()

	if entity.section_name == "predefined_squad" then
		local ids = entity.ids
		for i=1, #ids do
			local squad = WorldState.objects[ids[i]]
			squad.stay_time = game.get_game_time()
			squad.force_online = true
			squads:add_se_obj(entity.entity_type, entity.group_id, i, squad, entity)
		end
		return squads
	end
	for i=1, entity.amount or 1 do
		local smart_name = SIMBOARD.smarts[entity.where].smrt:name()
		local squad = utils_obj.create_squad(entity.section_name, smart_name)
		squad.stay_time = game.get_game_time()
		squad.force_online = true

		squads:add_se_obj(entity.entity_type, entity.group_id, i, squad, entity)
	end

	return squads
end

function create_item(entity)
	if entity.ids then	-- TODO: distinction with flag
		return setup_existing_items(entity)
	elseif SIMBOARD.smarts[entity.where] then
		return create_item_on_smart(entity)
	elseif tonumber(entity.where) then
		return create_item_in_inventory(entity)
	else
		return create_item_on_coords(entity)
	end
end

function quest_target(entity)
	return entity.id
end

function get_completed_money(entity)
	return 3000
end

function get_completed_goodwill(entity)
	return 25
end

function get_factions(entity, task_giver_id)
	local faction = trace_assert(
		igi_helper.get_community_by_id(task_giver_id),
		'No community')
	return {faction}
end

function get_failed_money(entity)
	return 0
end

function get_failed_goodwill(entity)
	return -25
end

function get_basic_reward_for_status(status, entity, task_giver_id)
	local target_tbl = entity:get_target_table()
	local goodwill = igi_rewards.GoodwillReward.new()
	goodwill:set_value(target_tbl["get_"..status:lower().."_goodwill"](entity))
	goodwill:set_factions(target_tbl.get_factions(entity, task_giver_id))

	money = igi_rewards.MoneyReward.new()
	money:set(target_tbl["get_"..status:lower().."_money"](entity))

	local t = igi_rewards.RewardTable.new()
	t:add(goodwill)
	t:add(money)
	return t
end

function initialise_rewards(entity, CACHE)
	local task_giver_id = CACHE:get_task_giver_id()
	entity.reward = igi_rewards.SubtaskRewards.new()
	entity.reward:set_reward_of_status(
		igi_subtask.TASK_STATUSES.COMPLETED,
		get_basic_reward_for_status(
			igi_subtask.TASK_STATUSES.COMPLETED, entity, task_giver_id)
	)
	entity.reward:set_reward_of_status(
		igi_subtask.TASK_STATUSES.FAILED,
		get_basic_reward_for_status(
			igi_subtask.TASK_STATUSES.FAILED, entity, task_giver_id)
	)
end

------------------------------------------------
-- TESTS
-- Well... tests ._.
------------------------------------------------
add_test = igi_unit_tests.add_test_partial("igi_target_basic")
local tables_are_same = igi_unit_tests.tables_are_same

add_test("setup_location", function()
	local result, expected

	local location_coords = {
		coords = "123,123,321"
	}
	expected = dup_table(location_coords)
	result = setup_location(location_coords)
	trace_assert(tables_are_same(result, expected))

	local location_id = {
		where = 0
	}
	expected = {
		id = 0
	}
	result = setup_location(location_id)
	trace_assert(tables_are_same(result, expected))

	local location_link = {
		where = "$link$"
	}
	expected = {
		id = "$link$"
	}
	result = setup_location(location_link)
	trace_assert(tables_are_same(result, expected))
end)
