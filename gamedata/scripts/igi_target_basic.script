------------------------------------------------
-- LOCALS
-- No actual grouping, these are used to lower other functions complexity
------------------------------------------------
local trace_dbg = igi_helper.trace_dbg
local trace_assert = igi_helper.trace_assert
local WorldState = igi_world_state.WorldState


local function ids_to_entities(prototype, ids)
	if prototype.amount == 'all' then
		prototype.amount = #ids
	end
	ids = igi_utils.get_random_items(ids, prototype.amount or 1)
	if not ids then return end

	prototype:bind_to_se_obj(ids[#ids])
	ids[#ids] = nil

	local new_entities = {}
	for _, id in ipairs(ids) do
		new_entities[#new_entities+1] = prototype:clone():binded_to(id)
	end
	return new_entities
end

local function unwrap_entity_amount(prototype)
	local new_entities = {}
	for _=2, prototype.amount or 1 do
		new_entities[#new_entities+1] = prototype:clone()
	end
	return new_entities
end

local function assert_has_valid_section(entity)
	local section = trace_assert(entity.section_name, "Section does not exist")
	trace_assert(ini_sys:section_exist(section), "bad section: "..section)
end

local function force_parent_online(se_obj)
	if se_obj.parent_id == 65535 then return end
	local parent = WorldState.objects[se_obj.parent_id]
	local p_clsid = parent:clsid()
	if IsStalker(parent, p_clsid)
			or IsMonster(parent, p_clsid)
			or p_clsid == clsid.online_offline_group_s
			then
		parent.force_online = true
		parent.stay_time = game.get_game_time()
	end
end

local function get_coords(str)
	trace_assert(type(str) == "string")
	local lvl, x, y, z = str:match("(.*),(.*),(.*),(.*)")
	x, y, z = tonumber(x), tonumber(y), tonumber(z)
	lvl = igi_db.LtxView("map_config.ltx").map_names[lvl]
	trace_assert(lvl, "ERROR: Can't get lvl! "..str)
	return lvl, x, y, z
end

------------------------------------------------
-- DESCRIPTION
-- Prepares description
------------------------------------------------

function get_location_description(entity)
	if not entity.id then return end
	local se_obj = WorldState.objects[entity.id]
	if SIMBOARD.smarts[entity.id] then
		return "st_"..se_obj:name().."_name"
	end
	return dynamic_news_helper.GetPointDescription(se_obj)
end

function get_se_entity_description(entity)
	local desc = igi_description.TaskDescription.new()
	local se_obj = WorldState.objects[entity.id]
	desc.locations:add(get_location_description(entity))

	if entity.entity_type == "squad" then
		desc.factions:add(se_obj.player_id)
	elseif igi_helper.is_common_npc(se_obj.parent_id) then
		local parent_npc = WorldState.objects[se_obj.parent_id]
		desc.factions:add(alife_character_community(parent_npc))
		desc.targets:add(parent_npc:character_name())
	end

	return desc
end

function get_description(entity)
	if not entity.to_create then
		return get_se_entity_description(entity)
	end

	local desc = igi_description.TaskDescription.new()
	if entity.entity_type == "squad" then
		desc.factions:add(entity.faction)
		desc.locations:add(entity.where)
	elseif entity.entity_type == "item" then
		desc.targets:add(ini_sys:r_string_ex(entity.section_name, "inv_name_short"))
	end
	return desc
end

------------------------------------------------
-- SETUP FUNCTIONS
-- Prepares objects for task, rolls random dice, finds objects in world
------------------------------------------------

function setup_location(entity)
	--trace_assert(entity.where or entity.coords, "location has no info")
	if entity.coords then
		return unwrap_entity_amount(entity)
	end

	if entity.id then
		entity:bind_to_se_obj(entity.id)
		return unwrap_entity_amount(entity)
	end

	if entity.name then
		local smart = trace_assert(
			SIMBOARD.smarts_by_names[entity.name],
			"Unknown name "..entity.name)
		entity:bind_to_se_obj(smart.id)
		entity.name = nil
		return unwrap_entity_amount(entity)
	end

	local ids
	if entity.search_for == 'smart' then
		ids = igi_finder.get_smarts(entity.where)
	elseif entity.search_for == 'stash' then
		ids = igi_finder.get_stashes(entity)
	else
		trace_assert(nil, "Unknown location type")
	end
	return ids_to_entities(entity, ids)
end

function setup_squad(entity)
	if entity.to_create then
		assert_has_valid_section(entity)
		return unwrap_entity_amount(entity)
	end

	local enemy_factions
	if entity.type == "mutant" then
		enemy_factions = igi_db.ini_tables["monster_types"]:as_set()
	elseif entity.type == "enemy" then
		enemy_factions = igi_helper.get_faction_enemies(character_community(db.actor))
	else
		enemy_factions = trace_assert(entity.factions, "No factions given")
	end

	local ids = igi_finder.get_squads_by_args(entity, enemy_factions)
	return ids_to_entities(entity, ids)
end

function setup_item(entity)
	if entity.to_create then
		assert_has_valid_section(entity)
		return unwrap_entity_amount(entity)
	end

	trace_assert(entity.item_list, "No item list given")
	local ids = igi_finder.get_objects_by_args(
		entity.item_list, entity)
	return ids_to_entities(entity, ids)
end

------------------------------------------------
-- CREATE FUNCTIONS
-- Called after getting a task to create/prepare actual game objects
------------------------------------------------

function create_location(entity)
	if entity.location_type == 'stash' then
		treasure_manager.set_random_stash(nil, nil, nil, entity.id)
	end
end

function create_squad(entity)
	if entity:is_binded_to_se_obj() then
		local squad = entity:get_binded_object()
		squad.stay_time = game.get_game_time()
		squad.force_online = true
		return
	end

	local smart_name = SIMBOARD.smarts[entity.where].smrt:name()
	local squad = utils_obj.create_squad(entity.section_name, smart_name)
	squad.stay_time = game.get_game_time()
	squad.force_online = true

	entity:bind_to_se_obj(squad.id)
end

function create_item(entity)
	if entity:is_binded_to_se_obj() then
		force_parent_online(entity:get_binded_object())
		return
	end

	local se_obj
	if SIMBOARD.smarts[entity.where] then -- TODO: distinction with flag
		local smart = SIMBOARD.smarts[entity.where].smrt
		local location = vector():set(
			smart.position.x,
			smart.position.y+1,
			smart.position.z)

		se_obj = alife_create(entity.section_name, location,
			smart.m_level_vertex_id, smart.m_game_vertex_id)
	elseif tonumber(entity.where) then
		local parent = WorldState.objects[entity.where]
		se_obj = alife_create_item(entity.section_name, parent)
	else
		local lvl, x, y, z = get_coords(entity.where)
		se_obj = alife_create(entity.section_name, vector():set(x,y+1,z), 0, lvl)
	end
	entity:bind_to_se_obj(se_obj.id)
end

------------------------------------------------
-- OTHER FUNCTIONS
-- Lorem ipsum dolor sit amet, consectetur adipiscing elit.
------------------------------------------------

function quest_target(entity)
	return entity.id
end

function get_completed_money(entity)
	return 3000
end

function get_completed_goodwill(entity)
	return 25
end

function get_factions(entity, task_giver_id)
	return {igi_helper.get_community_by_id(task_giver_id)}
end

function get_failed_money(entity)
	return 0
end

function get_failed_goodwill(entity)
	return -25
end

function get_raw_reward(entity, task_giver_id)
	local target_tbl = entity:get_target_table()
	local status = entity:get_status():lower()
	local reward = igi_rewards.RewardTable.new()

	local goodwill = reward:get('goodwill')
	goodwill:set_value(target_tbl["get_"..status.."_goodwill"](entity))
	goodwill:set_factions(target_tbl.get_factions(entity, task_giver_id))

	local money = reward:get('money')
	money:set(target_tbl["get_"..status.."_money"](entity))

	return reward
end

function get_reward(entity, task_giver_id)
	local target_tbl = entity:get_target_table()
	local raw_reward = target_tbl.get_raw_reward(entity, task_giver_id)
	local reward = entity:get_reward_table()
	reward:combine_with(raw_reward)
	return reward
end
