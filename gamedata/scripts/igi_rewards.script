local trace_assert = igi_helper.trace_assert
local trace_dbg = igi_helper.trace_dbg
local WorldState = igi_world_state.WorldState
local TASK_STATUSES = igi_subtask.TASK_STATUSES

function on_game_start()
	RegisterScriptCallback("actor_on_first_update", actor_on_first_update)
end

function actor_on_first_update()
	igi_models.add_interface_implementation('Cache', Cache)
	igi_models.add_interface_implementation('Entity', Entity)
	igi_models.add_interface_implementation('EntitiesTable', EntitiesTable)
	igi_models.add_interface_implementation(GoodwillReward.__cls, GoodwillReward)
	igi_models.add_interface_implementation(MoneyReward.__cls, MoneyReward)
	igi_models.add_interface_implementation(RewardTable.__cls, RewardTable)
	igi_models.add_interface_implementation(SubtaskRewards.__cls, SubtaskRewards)

	igi_taskdata.add_classification_rule(function (CACHE)
		if CACHE.rewards then
			igi_models.set_class(CACHE.rewards, SubtaskRewards.__cls)
			CACHE.rewards:repair_self()
		end
		if not CACHE:get_entities() then return end
		for _, entity in pairs(CACHE:get_entities())do
			if entity.rewards then
				igi_models.set_class(entity.rewards, SubtaskRewards.__cls)
				entity.rewards:repair_self()
			end
		end
	end)
end


Cache = {
	collect_and_give_rewards = function (self)
		local rewards = self.rewards or SubtaskRewards.new()
		local reward
		if self:is_task_completed() then
			reward = rewards:get(TASK_STATUSES.COMPLETED)
		else
			reward = rewards:get(TASK_STATUSES.FAILED)
		end

		local t = self:get_entities():collect_rewards_from_subtasks(
			self:is_task_completed(),
			self:get_task_giver_id()
		)
		reward:combine_with(t)

		igi_callbacks.invoke_callbacks("on_before_rewarding")
		reward:give()
	end,

	has_material_rewards = function (self)
		return self:get_entities():has_material_rewards()
	end
}

EntitiesTable = {
	_collect_rewards_with_status = function (self, status, tg_id)
		local reward_tbl = RewardTable.new()
		trace_dbg('Entities, status', self, status)
		for _, entity in pairs(self) do
			if entity:get_status() == status then
				local entity_reward = entity:get_final_reward(tg_id)
				reward_tbl:combine_with(entity_reward)
				trace_dbg('combined', reward_tbl)
			end
		end
		return reward_tbl
	end,

	collect_rewards_from_subtasks = function (self, is_successful, tg_id)
		local reward_tbl = RewardTable.new()

		-- Always add failed: if task is successful then these ones are failed optionals
		local t = self:_collect_rewards_with_status(igi_subtask.TASK_STATUSES.FAILED, tg_id)
		reward_tbl:combine_with(t)
		if is_successful then
			t = self:_collect_rewards_with_status(igi_subtask.TASK_STATUSES.COMPLETED, tg_id)
			reward_tbl:combine_with(t)
		end
		trace_dbg("Rewards from subtasks: ", reward_tbl)
		return reward_tbl
	end,

	has_material_rewards = function (self)
		return true
	end,
}

Entity = {
	get_final_reward = function (self, task_giver_id)
		return self:get_target_table().get_reward(self, task_giver_id)
	end,

	get_reward_table = function (self)
		return self:get_all_rewards():get(self:get_status())
	end,

	get_all_rewards = function (self)
		if not self.rewards then
			self.rewards = SubtaskRewards.new()
		end
		return self.rewards
	end,
}

SubtaskRewards = {
	__cls = "SubtaskRewards",

	new = function ()
		local t = {}
		igi_models.set_class(t, SubtaskRewards.__cls)
		return t
	end,

	repair_self = function (self)
		for status, reward_table in pairs(self) do
			trace_assert(igi_subtask.TASK_STATUSES[status], "Unknown task status")
			igi_models.set_class(reward_table, RewardTable.__cls)
			reward_table:repair_self()
		end
	end,

	get = function (self, status)
		trace_assert(igi_subtask.TASK_STATUSES[status], "Unknown task status")
		if not self[status] then
			self[status] = RewardTable.new()
		end
		return self[status]
	end,

	set_reward_of_status = function (self, status, reward)
		trace_assert(igi_subtask.TASK_STATUSES[status], "Unknown task status")
		trace_assert(reward.__cls == RewardTable.__cls, "Not a reward table")
		self[status] = reward
	end,
}


RewardTable = {
	__cls = 'RewardTable',

	_classes = {},

	add_class = function (key, class)
		trace_assert(class.__cls, 'Class is not a class')
		RewardTable._classes[key] = class
	end,

	new = function ()
		local t = {}
		igi_models.set_class(t, RewardTable.__cls)
		return t
	end,

	get = function (self, key)
		if not self[key] then
			trace_assert(self._classes[key], "Unknown reward type: "..key)
			self[key] = self._classes[key].new()
		end
		return self[key]
	end,

	repair_self = function (self)
		for k, v in pairs(self) do
			if k ~= "blocked" then
				igi_models.set_class(v, self._classes[k].__cls)
			end
		end
	end,

	combine_with = function (self, other)
		trace_assert(other.__cls == RewardTable.__cls, 'Tried to add wrong type')
		other:finalize()
		return_block = other:unblock()

		trace_dbg("Combine: self, other", self, other)

		for k, reward in pairs(other) do
			if (not self.blocked) or self[k] then
				self:get(k):combine_with(reward)
			end
		end

		return_block(other)
	end,

	unblock = function (self)
		local was_blocked = self.blocked
		self.blocked = nil
		if was_blocked then return self.block end
		return function () end
	end,

	block = function (self)
		self.blocked = true
	end,

	finalize = function (self)
		local return_block = self:unblock()
		for _, reward in pairs(self) do
			reward:apply_multiplier()
			reward:apply_additional_value()
		end
		return_block(self)
	end,

	has_material_rewards = function (self)
		for k, reward in pairs(self) do
			if k ~= "blocked" and reward:is_material() then
				return true
			end
		end
		return false
	end,

	add = function (self, reward)
		self:get(reward.__key):combine_with(reward)
	end,

	give = function (self)
		local return_block = self:unblock()
		for _, reward in pairs(self) do
			reward:give()
		end
		return_block(self)
	end,
}

AbstractReward = {
	__cls = 'AbstractReward',

	_empty_func = function () end,

	unblock = function (self)
		local was_blocked = self.blocked
		self.blocked = nil
		if was_blocked then return self.block end
		return AbstractReward._empty_func
	end,

	block = function (self)
		self.blocked = true
	end,

	is_material = function (self)
		return true
	end,
}

GoodwillReward = {
	__cls = 'GoodwillReward',
	__key = 'goodwill',

	new = function()
		local t = {
			value = 0,
			factions = {},
			factions_goodwill = {},
		}
		igi_models.set_class(t, GoodwillReward.__cls)
		return t
	end,

	_assert_faction_exists = function (self, faction)
		trace_assert(igi_world_state.WorldState.factions[faction], "Faction not found: ", faction)
	end,

	normalize = function(self)
		trace_dbg("rewards" ,self)
		-- Goodwill (1/gaussian_sum to last community, 2/sum to second last, ..., 1/2 to first)
		local factions = self.factions
		local parts = (#factions)*(#factions+1)/2

		for i=1,#factions do
			local faction_value = math.floor((i*self.value)/parts)
			local faction = factions[#factions+1-i]
			self:add_for_faction(faction, faction_value)
		end
	end,

	denormalize = function (self)
		for faction, v in pairs(self.factions_goodwill) do
			self:add(v)
			self:add_faction(faction)
		end
	end,

	rebalance = function (self)
		self:denormalize()
		self:normalize()
	end,

	add = function (self, value)
		if self.blocked then return end
		trace_assert(type(value) == "number", "Trying to set a non-number goodwill value")
		self.value = self.value + value
	end,

	add_faction = function (self, faction)
		if self.blocked then return end
		self:_assert_faction_exists(faction)
		for _, v in pairs(self) do
			if v == faction then return	end
		end
		self.factions[#self.factions+1] = faction
	end,

	set_factions = function (self, factions)
		empty_table(self.factions)
		for _, faction in pairs(factions) do
			self:add_faction(faction)
		end
	end,

	set_value = function (self, value)
		trace_assert(type(value) == "number", "Trying to set a non-number goodwill value")
		self.value = value
	end,

	set_for_faction = function (self, faction, value)
		self:_assert_faction_exists(faction)
		self.factions_goodwill[faction] = value
	end,

	get_for_faction = function (self, faction)
		return rawget(self.factions_goodwill, faction) or 0
	end,

	add_for_faction = function (self, faction, value)
		if self.blocked then return end
		local new_val = self:get_for_faction(faction) + value
		self:set_for_faction(faction, new_val)
	end,

	get_factions_goodwill = function (self)
		return self.factions_goodwill
	end,

	apply_additional_value = function (self)
		if not self.additional then return end
		local to_add = self.additional/size_table(self.factions_goodwill)
		for k, val in pairs(self.goodwill) do
			self.goodwill[k] = val + to_add
		end
	end,

	apply_multiplier = function (self)
		if not self.multiplier then return end
		for k, val in pairs(self.goodwill) do
			self.goodwill[k] = val*self.multiplier
		end
		self.multiplier = nil
	end,

	_factions_defined = function (self)
		if not self.factions then self.factions = {} end
		if not self.factions_goodwill then self.factions_goodwill = {} end
		return next(self.factions) or next(self.factions_goodwill)
	end,

	_get_denormalized_factions = function (self)
		self:normalize()
		local factions_goodwill = self:get_factions_goodwill()
		sorted = {}

		for k in pairs(factions_goodwill) do
			sorted[#sorted+1] = k
		end

		table.sort(sorted, function(a,b)
			return factions_goodwill[a] > factions_goodwill[b]
		end)
		return sorted
	end,

	combine_with = function (self, other)
		other:normalize()
		if self.blocked and not self:_factions_defined() then
			self:set_factions(other:_get_denormalized_factions())
			self:normalize()
			return
		end

		self:normalize()
		for faction, goodwill in pairs(other:get_factions_goodwill()) do
			self:add_for_faction(faction, goodwill)
		end
	end,

	give = function (self)
		self:normalize()
		for faction, value in pairs(self:get_factions_goodwill()) do
			if value ~= 0 then
				xr_effects.complete_task_inc_goodwill(nil, nil, {value, faction})
			end
		end
	end,

	is_material = function (self)
		return false
	end,

	unblock = AbstractReward.unblock,
	block = AbstractReward.block,
}
RewardTable.add_class(GoodwillReward.__key, GoodwillReward)

MoneyReward = {
	__cls = "MoneyReward",
	__key = 'money',

	new = function ()
		local t = {value = 0,}
		igi_models.set_class(t, MoneyReward.__cls)
		return t
	end,

	set = function (self, v)
		self.value = v
	end,

	get = function (self)
		return self.value
	end,

	add = function (self, v)
		if self.blocked then return end
		self.value = self.value + v
	end,

	apply_additional_value = function (self)
		if not self.additional then return end
		self:add(self.additional)
	end,

	apply_multiplier = function (self)
		if not self.multiplier then return end
		self:set(self:get()*self.multiplier)
	end,

	combine_with = function (self, other)
		if self.blocked then return end
		self:add(other:get())
	end,

	give = function (self)
		local money = self.value
		money = money*igi_mcm.get_options_value("money_reward_coeff")
		if money ~= 0 then
			local min = money*igi_mcm.get_options_value("reward_spread_min")
			local max = money*igi_mcm.get_options_value("reward_spread_max")
			xr_effects.reward_random_money(nil, nil, {min, max})
		end
	end,

	is_material = function (self)
		return self.value > 0
	end,

	unblock = AbstractReward.unblock,
	block = AbstractReward.block,
}
RewardTable.add_class(MoneyReward.__key, MoneyReward)
