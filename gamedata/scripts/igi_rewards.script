local trace_assert = igi_helper.trace_assert
local trace_dbg = igi_helper.trace_dbg
local WorldState = igi_world_state.WorldState

function on_game_start()
	RegisterScriptCallback("actor_on_first_update", actor_on_first_update)
end

function actor_on_first_update()
	igi_models.add_interface_implementation('Cache', Cache)
	igi_models.add_interface_implementation('Entity', Entity)
	igi_models.add_interface_implementation('EntitiesTable', EntitiesTable)
	igi_models.add_interface_implementation(GoodwillReward.__cls, GoodwillReward)
	igi_models.add_interface_implementation(MoneyReward.__cls, MoneyReward)
	igi_models.add_interface_implementation(RewardTable.__cls, RewardTable)
	igi_models.add_interface_implementation(SubtaskRewards.__cls, SubtaskRewards)

	igi_taskdata.add_classification_rule(function (CACHE)
		if CACHE.immutable_rewards then
			igi_models.set_class(CACHE.immutable_rewards, SubtaskRewards.__cls)
			CACHE.immutable_rewards:repair_self()
		end
		if not CACHE:get_setup() then return end
		for _, entity in pairs(CACHE:get_setup())do
			if entity.reward then
				igi_models.set_class(entity.reward, SubtaskRewards.__cls)
				entity.reward:repair_self()
			end

			if entity.immutable_rewards then
				igi_models.set_class(entity.immutable_rewards, SubtaskRewards.__cls)
				entity.immutable_rewards:repair_self()
			end
		end
	end)
end


Cache = {
	_collect_rewards = function (self)
		self.reward = RewardTable.new()
		self:get_entities():collect_rewards_from_subtasks(
			self:is_task_completed(),
			self.reward
		)

		--reward_tbl:set_global_immutable_rewards(self) TODO
		self.reward:apply_modifiers()
	end,

	collect_and_give_rewards = function (self)
		self:_collect_rewards()
		igi_callbacks.invoke_callbacks("on_before_rewarding")
		self:_give_rewards()
	end,

	_give_rewards = function (self)
		for _, reward in pairs(self.reward) do
			reward:give()
		end
	end,

	initialise_rewards = function (self)
		for _, entity in pairs(self:get_entities()) do
			if entity.target then
				local target_tbl = entity:get_target_table()
				target_tbl.initialise_rewards(entity, self)
			end
		end
	end,

	has_material_rewards = function (self)
		return self:get_entities():has_material_rewards()
	end
}

EntitiesTable = {
	_add_rewards_with_status = function (self, reward_tbl, status)
		trace_dbg('Entities, status', self, status)
		for _, entity in pairs(self) do
			if entity:get_status() == status then
				local entity_reward = entity:get_reward_tbl()
				reward_tbl:combine_with(entity_reward)
				trace_dbg('combined', reward_tbl)
			end
		end
	end,

	collect_rewards_from_subtasks = function (self, is_successful, reward_tbl)
		trace_assert(reward_tbl.__cls == RewardTable.__cls, 'Not a reward table')

		-- Always add failed: if task is successful then these ones are failed optionals
		self:_add_rewards_with_status(reward_tbl, igi_subtask.TASK_STATUSES.FAILED)
		if is_successful then
			self:_add_rewards_with_status(reward_tbl, igi_subtask.TASK_STATUSES.COMPLETED)
		end
		trace_dbg("Rewards from subtasks: ", reward_tbl)
	end,

	has_material_rewards = function (self)
		for _, entity in pairs(self) do
			if entity:get_reward_tbl():has_material_rewards() then
				return true
			end
		end
		return false
	end,
}

Entity = {
	get_reward_tbl = function (self)
		local status = self:get_status()
		local reward_tbl = self.reward and self.reward[status]
		trace_dbg('reward table', self, reward_tbl)
		if not reward_tbl then return end

		local immutable_rewards = self.immutable_rewards and self.immutable_rewards[status]
		if not immutable_rewards then return reward_tbl end
		reward_tbl:set_immutable_rewards(reward_tbl, immutable_rewards)

		return reward_tbl
	end
}

SubtaskRewards = {
	__cls = "SubtaskRewards",

	new = function ()
		local t = {}
		igi_models.set_class(t, SubtaskRewards.__cls)
		return t
	end,

	repair_self = function (self)
		for status, reward_table in pairs(self) do
			trace_assert(igi_subtask.TASK_STATUSES[status], "Unknown task status")
			igi_models.set_class(reward_table, RewardTable.__cls)
			reward_table:repair_self()
		end
	end,

	get_reward_of_status = function (self, status)
		trace_assert(igi_subtask.TASK_STATUSES[status], "Unknown task status")
		if not self[status] then
			self[status] = RewardTable.new()
		end
		return self[status]
	end,

	set_reward_of_status = function (self, status, reward)
		trace_assert(igi_subtask.TASK_STATUSES[status], "Unknown task status")
		trace_assert(reward.__cls == RewardTable.__cls, "Not a reward table")
		self[status] = reward
	end,
}


RewardTable = {
	__cls = 'RewardTable',

	_factories = {},

	add_factory = function (key, factory)
		trace_assert(type(factory) == "function", 'Factory is not a function')
		RewardTable._factories[key] = factory
	end,

	new = function ()
		local t = {}
		igi_models.set_class(t, RewardTable.__cls)
		return t
	end,

	get = function (self, key)
		if not self[key] then
			trace_assert(self._factories[key], "Unknown reward type: "..key)
			self[key] = self._factories[key]()
		end
		return self[key]
	end,

	repair_self = function (self)
		if self.goodwill then
			igi_models.set_class(self.goodwill, GoodwillReward)
		end
	end,

	_set_immutable_rewards = function (self, immutable_rewards)
		for k, reward in pairs(immutable_rewards) do
			self:get_reward(k):set_immutable(reward)
		end
	end,

	combine_with = function (self, other)
		trace_assert(other.__cls == RewardTable.__cls, 'Tried to add wrong type')
		other:apply_modifiers()

		for k, reward in pairs(other) do
			self:get(k):combine_with(reward)
		end
	end,

	apply_modifiers = function (self)
		for _, reward in pairs(self) do
			reward:apply_multiplier()
			reward:apply_additional_value()
		end
	end,

	set_global_immutable_rewards = function (self, CACHE)
		if not CACHE.immutable_rewards then return end
		local immutable_reward = CACHE.immutable_rewards[CACHE.status]
		if not immutable_reward then return end
		self:_set_immutable_rewards(immutable_reward)
		trace_dbg("Rewards with immutables: ", self)
	end,

	has_material_rewards = function (self)
		for _, reward in pairs(self) do
			if reward.is_material then
				return true
			end
		end
		return false
	end,

	add = function (self, reward)
		self:get(reward.__key):combine_with(reward)
	end,
}

GoodwillReward = {
	__cls = 'GoodwillReward',
	__key = 'goodwill',

	new = function()
		local t = {
			value = 0,
			factions = {},
			factions_goodwill = {},
		}
		igi_models.set_class(t, GoodwillReward.__cls)
		return t
	end,

	_assert_faction_exists = function (self, faction)
		trace_assert(igi_world_state.WorldState.factions[faction], "Faction not found: ", faction)
	end,

	normalize = function(self)
		trace_dbg("rewards" ,self)
		-- Goodwill (1/gaussian_sum to last community, 2/sum to second last, ..., 1/2 to first)
		local factions = self.factions
		local parts = (#factions)*(#factions+1)/2

		for i=1,#factions do
			local faction_value = math.floor((i*self.value)/parts)
			local faction = factions[#factions+1-i]
			self:add_for_faction(faction, faction_value)
		end
	end,

	denormalize = function (self)
		for faction, v in pairs(self.factions_goodwill) do
			self:add(v)
			self:add_faction(faction)
		end
	end,

	rebalance = function (self)
		self:denormalize()
		self:normalize()
	end,

	add_faction = function (self, faction)
		self:_assert_faction_exists(faction)
		for _, v in pairs(self) do
			if v == faction then return	end
		end
		self.factions[#self.factions+1] = faction
	end,

	set_factions = function (self, factions)
		empty_table(self.factions)
		for _, faction in pairs(factions) do
			self:add_faction(faction)
		end
	end,

	set_value = function (self, value)
		trace_assert(type(value) == "number", "Trying to set a non-number goodwill value")
		self.value = value
	end,

	set_for_faction = function (self, faction, value)
		self:_assert_faction_exists(faction)
		self.factions_goodwill[faction] = value
	end,

	get_for_faction = function (self, faction)
		return rawget(self.factions_goodwill, faction) or 0
	end,

	add_for_faction = function (self, faction, value)
		local new_val = self:get_for_faction(faction) + value
		self:set_for_faction(faction, new_val)
	end,

	get_factions_goodwill = function (self)
		return self.factions_goodwill
	end,

	apply_additional_value = function (self)
		if not self.additional then return end
		local to_add = self.additional/size_table(self.factions_goodwill)
		for k, val in pairs(self.goodwill) do
			self.goodwill[k] = val + to_add
		end
	end,

	apply_multiplier = function (self)
		if not self.multiplier then return end
		for k, val in pairs(self.goodwill) do
			self.goodwill[k] = val*self.multiplier
		end
		self.multiplier = nil
	end,

	combine_with = function (self, other)
		trace_assert(other.__cls == GoodwillReward.__cls, 'Tried to add wrong type')
		self:normalize()
		other:normalize()
		for faction, goodwill in pairs(other:get_factions_goodwill()) do
			self:add_for_faction(faction, goodwill)
		end
	end,

	give = function (self)
		self:normalize()
		for faction, value in pairs(self:get_factions_goodwill()) do
			if value ~= 0 then
				xr_effects.complete_task_inc_goodwill(nil, nil, {value, faction})
			end
		end
	end,

	set_immutable = function (self, immutable)
		immutable:normalize()
		self.value = 0
		self.factions_goodwill = immutable.factions_goodwill
	end
}
RewardTable.add_factory(GoodwillReward.__key, GoodwillReward.new)

MoneyReward = {
	__cls = "MoneyReward",
	__key = 'money',
	is_material = true,

	new = function ()
		local t = {value = 0,}
		igi_models.set_class(t, MoneyReward.__cls)
		return t
	end,

	set = function (self, v)
		self.value = v
	end,

	get = function (self)
		return self.value
	end,

	add = function (self, v)
		self.value = self.value + v
	end,

	apply_additional_value = function (self)
		if not self.additional then return end
		self:add(self.additional)
	end,

	apply_multiplier = function (self)
		if not self.multiplier then return end
		self:set(self:get()*self.multiplier)
	end,

	combine_with = function (self, other)
		self:add(other:get())
	end,

	give = function (self)
		local money = self.value
		money = money*igi_mcm.get_options_value("money_reward_coeff")
		if money ~= 0 then
			local min = money*igi_mcm.get_options_value("reward_spread_min")
			local max = money*igi_mcm.get_options_value("reward_spread_max")
			xr_effects.reward_random_money(nil, nil, {min, max})
		end
	end,

	set_immutable = function (self, immutable)
		self:set(immutable.value)
	end
}
RewardTable.add_factory(MoneyReward.__key, MoneyReward.new)
