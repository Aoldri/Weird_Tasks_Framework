
local trace_dbg = igi_helper.trace_dbg
local trace_assert = igi_helper.trace_assert

function on_game_start()
	RegisterScriptCallback("actor_on_first_update", actor_on_first_update)
end

function actor_on_first_update()
	igi_models.add_interface_implementation(Entity.__cls, Entity)
	igi_models.add_interface_implementation('Cache', Cache)
	igi_models.add_interface_implementation(EntitiesTable.__cls, EntitiesTable)
end

Cache = {
	get_entities = function (self)
		return self.target
	end,

	get_group_counter = function (self)
		return self.group_counter
	end,

	set_entities = function (self, entities)
		self.target = entities
	end
}

EntitiesTable = {
	__cls = 'EntitiesTable',

	new = function ()
		local t = {__cls = EntitiesTable.__cls}
		igi_models.restore_object_interface(t)
		return t
	end,

	add_se_obj = function (self, typ, group_id, entity_id, se_obj, group_data)
		trace_assert(typ and group_id and entity_id and se_obj,
			"Something went wrong while adding entry")

		local entity = Entity.new(typ, group_id, entity_id)
		entity:link_to_se_obj(se_obj)
		entity:add_group_data(group_data)
		self[entity:get_link()] = entity
	end,

	add = function (self, group_id, entity_id, obj_data, group_data)
		trace_assert(group_id and entity_id and obj_data,
			"Something went wrong while adding entry")

		local entity = Entity.new(group_data.entity_type, group_id, entity_id)
		entity:add_group_data(obj_data)
		entity:add_group_data(group_data)
		self[entity:get_link()] = entity
	end,

	count_types = function (self)
		local counter = igi_utils.defaultdict(0)
		for _, v in pairs(self) do
			counter[v.entity_type] = counter[v.entity_type] + 1
		end
		return counter
	end,
}

Entity = {
	__cls = 'Entity',

	new = function (typ, group_id, entity_id)
		local t = {
			__cls = Entity.__cls,
			entity_type = typ,
			group_id = group_id,
			entity_id = entity_id
		}
		igi_models.restore_object_interface(t)
		return t
	end,

	link_to_se_obj = function (self, se_obj)
		self.id = se_obj.id
		self.section_name = se_obj:section_name()
	end,

	add_group_data = function (self, group_data)
		if not group_data then return end
		trace_assert(type(group_data) == "table", 'not table')
		for k,v in pairs(group_data) do
			self[k] = self[k] or v
		end
	end,
}

local function create_group_by_setup(entities_setup)
	local target_tbl = igi_taskdata.get_target_table(entities_setup.target or "basic")
	local handler = target_tbl["create_"..entities_setup.entity_type]
    local group_data = handler(entities_setup)
	trace_dbg("group_data", group_data)
	return group_data
end


function create_target(CACHE)
	local setup = CACHE:get_setup()
    local targets = EntitiesTable.new()
    local created_keys = {}

	-- if it's not ready after #entities_setup tries, it won't be ready
    for _ in pairs(setup) do
        for k,entity_setup in pairs(setup) do
            if not created_keys[k] and igi_linker.has_no_outer_links(entity_setup) then
			    trace_dbg("entity_setup", entity_setup)
				igi_text_processor.process_unlinked_entity(entity_setup)
				trace_dbg("processed entity", entity_setup)

                local group_data = create_group_by_setup(entity_setup)
				created_keys[k] = true

				for link, entity in pairs(group_data) do
					targets[link] = entity

					igi_linker.broadcast_entity(entity, setup)
					trace_dbg("After broadcasting "..link, setup)
				end
            end
        end
    end

    CACHE:set_entities(targets)
	igi_callbacks.invoke_callbacks("on_after_target_creation", CACHE)
end
