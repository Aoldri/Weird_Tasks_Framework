-- Main setup function for all quests

local function setup_squad(squad_info, smarts, factions)	-- TODO: Custom smarts
	local squad_types = {
		["guard"] = gt_database.GUARD_SQUAD,
		["heavy_start_game"] = gt_database.HEAVY_SQUAD["start_game"],
		["heavy_midgame"] = gt_database.HEAVY_SQUAD["midgame"],
		["heavy_endgame"] = gt_database.HEAVY_SQUAD["endgame"],
		["mutant_start_game"] = gt_database.MUTANT_SQUAD["start_game"],
		["mutant_midgame"] = gt_database.MUTANT_SQUAD["midgame"],
		["mutant_endgame"] = gt_database.MUTANT_SQUAD["endgame"],
	}
	
	assert(squad_types[squad_info.type], "Igi: setup squad: Unknown squad type")
	local squad_name
	local squad_type
	local faction
	printf("IGI: squad_type: " .. squad_info.type)
	if string.find(squad_info.type, "mutant") then
		printf("Igi: me here")
		squad_name, squad_type = gt_utils.random_table_element(squad_types[squad_info.type])
		printf("Igi: me here with " .. squad_name)
	else
		assert(squad_info.faction or squad_info.faction_type, "Igi: setup_squad: No faction data")
		faction = squad_info[squad_info.faction] or factions[squad_info.faction_type]
		squad_name = squad_types[squad_info.type][faction]
	end

	assert(squad_name, "Igi: setup_squad: Unable to set squad_name")
	local squad_data = {
		["name"] = squad_name, 
		['faction'] = faction or "mutant",
		['description_data'] = {
			["factions"] = faction or nil,	-- none for mutant
			["targets"] = squad_type or nil,	-- none for stalkers
		},
		['target'] = squad_info.target or "kill",
		['amount'] = squad_info.amount or 1,
		['online_activities'] = squad_info.online_activities,
	}

	return squad_data
end

local function setup_smarts(smarts)  -- check
	-- This function returns a smart suitable for a quest
	local amount = smarts and smarts.amount or 1;
	local possible_smarts = gt_helper.check_smarts(
		SIMBOARD.smarts_by_names,smarts and smarts.is_nearby, smarts and smarts.is_online)
	
	if #possible_smarts < amount then
		return nil
	end

	local smarts_list = gt_utils.get_random_items(possible_smarts, amount)
	
	return smarts_list
end

local function setup_package(pkg_info, smarts, factions)				-- TODO: Custom smarts
	local pkgs = {}
	
	local pkg_data = gt_database.PACKAGE[pkg_info["package_type"]] or gt_helper.pick_quest_goods(pkg_info.quest_type)
	local amount = pkg_info["amount"] or gt_database.PACKAGE[pkg_data.package_type].default_amount_package
	
	if not pkg_data or not amount then
		printf("Igi: setup_package: Can't get type of package or amount")
		return nil, "Can't get type of package"
	end

	pkg_data.amount = amount
	pkg_data.description_data = {["targets"] = gt_database.TEXT_HEADER .. pkg_data.package_type}
	pkg_data.target = pkg_info.target
	return pkg_data
end

local function setup_item(item_data, smarts, factions)
	printf("Igi: Setup_item")
	assert(item_data.item_type or item_data.item_list, "Igi: setup_item: No item list given")
	local TYPE_TO_LIST = {
		["weapon_start_game"] = gt_database.WEAPONS_START_GAME,
		["weapon_midgame"] = gt_database.WEAPONS_MIDGAME,
		["weapon_endgame"] = gt_database.WEAPONS_ENDGAME,
		["artifact"] = gt_helper.get_artifact_names(),
	}
	local ENDINGS = {
		['artifact_boxes'] = gt_database.ARTIFACT_BOXES_ENDINGS,
	}
	
	local item_list = TYPE_TO_LIST[item_data.item_type]
	assert(item_list, "Igi: setup_item: No item_list")
	item_data.endings_list = ENDINGS[item_data.possible_endings]

	local objects
	local object_data = {}
	if item_data.to_create then
		printf("TODO")		-- TODO
	else
		local item_set = gt_utils.list_to_set(item_list)
		item_data.enemy_to = item_data.enemy_to or factions[item_data.enemy_to]
		printf("Igi: find start")
		objects = gt_helper.find_objects_ids(item_set, item_data)
		if not next(objects) then return nil end
		printf("Alles gut")
		objects = gt_utils.get_random_items(objects, item_data.amount or 1)
		
		object_data.target = item_data.target
		object_data.id = objects[1]
		printf("Igi: %s", object_data.id)
		local parent_id = gt_helper.alife_obj(object_data.id).parent_id
		local parent_npc = gt_helper.check_common_npc(parent_id) and gt_helper.alife_obj(parent_id)
		local location = alife():level_name(game_graph():vertex(gt_helper.alife_obj(object_data.id).m_game_vertex_id):level_id())
		object_data.description_data = {
			['factions'] = parent_npc and gt_helper.get_community(parent_npc) or nil,
			['targets'] = parent_npc and parent_npc:character_name() or item_data.item_type,
			['smarts'] = location
		}
	end
	
	return object_data
end

function setup_quest(args)
	-- This is generic function that sets everything you need for a quest
	-- Possible args:
	-- smarts (table) : {amount (int) - how many smarts to prepare,
	--					 is_nearby, is_online (bool) - smart attributes,
	--					 to_description (int) - n-th smart used for description}
	-- squads (table of tables) : {{amount (int),
	--								faction (string) OR		- can be any faction in game
	--								faction_type (string) - can be "enemy", "client" or "quest_giver",
	--								type (string) - can be "guard" or "heavy",
	--								target (string) - can be "kill", "save" or "contact"; default: kill,
	--								to_description (bool) - set squad faction as one of description factions, default: true
	--								}
	--								{*squads of another type with the same fields*}}
	-- packages (table of tables): {{amount (int), default: standart amount for this quest type
	--								 package_type (string) OR - must be in gt_database.PACKAGE,
	--								 quest_type (string) - see gt_database.QUEST_TO_POSSIBLE_GOODS,
	--								 smart_to_create (int) - if create: create in n-th smart, default: smarts[1]
	--								 target (string) - 'return', 'take' or 'open',
	--								 to_description (bool) - set package_type as one of description targets; default: true
	--},
	--								{*packages of another types with the same fields*}}
	-- items (table of tables): {{amount (int),
	--							  item_type (string) - only "artifact" and "weapon_*lowcost, midgame, endgame or legend*" rn OR
	--							  item_list (list) 	- search/create random item from list
	--							  to_create (bool) - TODO, if not create - then find
	--							  in_npc_inv (bool) - create(search) in npc inventories,
	--							  npc_identity (string) - 'friend', 'enemy', 'all' or faction
	--							  in_world (bool) - create(search) in world,
	--							  enemy_to (string) - if only_enemies then faction or "client" or "enemy" or "quest_giver"; default: player
	--							  npc_to_create (int) - TODO, if create: create in inventory of npc with this squad group,
	--							  smart_to_create (smart) - if create: create in n-th smart, default: 1},
	--							 {*items of another types with the same fields*}}
	local constructor = {}
	copy_table(constructor, args)
	args = gt_helper.scale_to_rank(constructor)		-- args are copied args with scale redone
	
	CACHE = {["setup"] = {},}
	CACHE["smarts"] = setup_smarts(args.smarts)
	if not CACHE.smarts then return nil end
	CACHE["factions"] = gt_helper.get_faction_setup()
	CACHE["description"] = {}
	if args.smarts and not args.smarts['not_show'] then
		CACHE.description.smarts = CACHE.smarts
	end
	
	local handlers = {
		["squads"] = setup_squad,
		["packages"] = setup_package,
		["items"] = setup_item,
	}
	
	for name, handler in pairs(handlers) do
		if args[name] then
			CACHE.setup[name] = {}
			for _, data in pairs(args[name]) do
				printf("Igi: setup: %s", name)
				local group_data = handler(data, CACHE.smarts, CACHE.factions)
				-- if impossible to make group - no setup
				if not group_data then return nil end
				-- custom args are booleans that will be used later
				group_data["custom_args"] = data.custom_args
				CACHE.setup[name][#CACHE.setup[name] + 1] = group_data
				
				if data.to_description ~= false then	
					for k, v in pairs(group_data.description_data) do
						CACHE.description[k] = CACHE.description[k] or {}
						if type(v) == 'table' then
							for _, value in pairs(v) do
								CACHE.description[k][#CACHE.description[k] + 1] = value
							end
						else 
							CACHE.description[k][#CACHE.description[k] + 1] = v
						end
					end
				
				end
			end
		end
	end
	return CACHE
end


