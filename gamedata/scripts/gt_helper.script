-- There are functions that are used by other complex functions

ARTIFACT_NAMES = {}
function get_artifact_names()						-- check
	-- creates a set of all artifacts in game
	if (next(ARTIFACT_NAMES) ~= nil) then return ARTIFACT_NAMES end	-- if set already created: return that set
	-- if set not created: create, save and return
	ARTIFACT_NAMES = {}
	local ini = ini_file("items\\settings\\artefacts.ltx")
	local n = ini:line_count("artefact_groups")
	for i=0,n-1 do -- for every artefact group:
		_, group_id = ini:r_line_ex("artefact_groups",i,"","")  -- write group id
		if ini:section_exist(group_id) then
			local m = ini:line_count(group_id)
			for j=0,m-1 do
				_, artifact_id = ini:r_line_ex(group_id,j,"","")
				if artifact_id and ini_sys:section_exist(artifact_id) then
					ARTIFACT_NAMES[artifact_id] = true -- for every artifact in group: add it's id as key
					--printf("GhenTuong: load artifact: %s", artifact_id)
				else
					printf("GhenTuong: load artifact from artefacts.ltx| incorrect section name: %s", artifact_id)
				end
			end
		end
	end
	return ARTIFACT_NAMES
end

function get_community(character)
	if not character then return nil end
	
	if character == db.actor then
		return character_community(character)
	else
		return alife_character_community(character)
	end
end

function object_in_world(obj)
	if not obj then return nil end
	return obj.parent_id == 65535
end

function object_in_npc_inventory(obj)
	if not obj then return nil end
	return check_common_npc(obj.parent_id)
end

function get_object_level_id(obj, --[[optional]] alife_obj, --[[optional]] game_graph_obj)
	-- obj must be alife object
	if not obj then return nil end
	-- these are to not run alife() or gg() multiple times
	alife_obj = alife_obj or alife()
	game_graph_obj = game_graph_obj or game_graph()
	
	local lvl_info_obj = 0
	if object_in_world(obj) then
		lvl_info_obj = obj
	elseif object_in_npc_inventory(obj) then
		lvl_info_obj = alife_obj:object(obj.parent_id)
	end
	
	local obj_level_id = game_graph_obj:vertex(lvl_info_obj.m_game_vertex_id):level_id()
	return obj_level_id
end

function get_object_level(obj, sim, gg)
	return sim:level_name(get_object_level_id(object, sim, gg))
end

local function get_faction_enemies(faction, --[[optional]] monolith_included)
	monolith_included = monolith_included or false
	local enemies_set = {}
	
	for enemy_faction in pairs(gt_database.FACTION_TO_GUARD) do
		if (game_relations.is_factions_enemies(faction, enemy_faction)) then
			if (enemy_faction ~= "monolith" or monolith_included) then
				enemies_set[enemy_faction] = true
			end
		end
	end
	return enemies_set
end

function check_smarts(smarts_table, --[[optional]] nearby_required, --[[optional]] online_required) -- check
	-- This function checks table of smarts for
	-->	- availability
	-->	- smart is not a base
	--> - smart is not in blacklisted_maps
	--> - (optional) online and on level of player (nearby)
	-- and returns a table of suitable smarts
	assert(type(smarts_table) == 'table', 'gt: check_smarts: not a table given')
	local return_list = {}
	local sim = alife()
	local gg = game_graph()
	local actor_level = level.name()
	
	for smart_name, smart_data in pairs(smarts_table) do
		if simulation_objects.available_by_id[smart_data.id] and	-- availability check
				not simulation_objects.base_smarts[smart_name] then	-- base smart check
			local smart_level = sim:level_name(gg:vertex(smart_data.m_game_vertex_id):level_id())
			
			if not gt_database.BLACKLISTED_MAPS[smart_level] then						-- blacklist check
				local is_online = smart_data.online
				local is_nearby = string.find(simulation_objects.config:r_value(actor_level, "target_maps", 0, ""), smart_level)
				
				if (is_nearby or not nearby_required) and (is_online or not online_required) then
					return_list[#return_list + 1] = smart_name
				end
			end
		end
	end
	return return_list
end

function is_online(object, sim, gg)
	player_level_id = get_object_level_id(db.player, sim, gg)
	object_level_id = get_object_level_id(object, sim, gg)
	return player_level_id == object_level_id
end

function is_nearby(object, sim, gg)
	local level = get_object_level(object, sim, gg)
	local actor_level = level.name()
	return string.find(simulation_objects.config:r_value(actor_level, "target_maps", 0, ""), level)
end

function is_on_blacklisted_map(object, sim, gg)
	object_lvl = get_object_level(object, sim, gg)
	if gt_database.BLACKLISTED_MAPS[object_lvl] then return true
	else return false end
end

function has_ending_in_list(object, ending_list)
	if not ending_list then return nil end
	
	for _, ending in pairs(ending_list) do
		if string.find(object:section_name(), ending) then
			return true end
	end
	return false
end

function find_objects_ids(name_set, --[[optional]] args) -- gl, check
	--[[ Well, this big horse shit function finds all objects, which names are in name_set (must be set)
			Possible args:
		nearby_required (bool) - search for objects that are on player's level (or i think so...)
		online_required (bool) - search for objects that are online
		id_range (list of 2 ints) - search for objects with id in this range
		possible endings (list of strings) - search for objects which name ends with one of these strings
		in_world (bool) - search in world									TODO
		in_npc_inv (bool) - search in npc's inventories
		only_npc (bool) - search only in npc's inventories					TODO
		only_enemies (bool) - if in_npc_inv: only in enemies's inventories
		enemy_to (alife character) - if only_enemies then enemies to this char's fraction 	TODO
		first_item_only (bool) - return list with first found item id			TODO
		with_blacklisted_maps (bool) - search in blacklisted maps
	]]
	assert(next(name_set) ~= nil, "gt: find_objects_ids: no name set given")
	assert(args.in_npc_inv or not(only_npc), "gt: find_objects_ids: only_npc but not in_npc_inv")
	assert(args.only_enemies or not(enemy_to), "gt: find_objects_ids: enemy_to but not only_enemies")
	id_range = args.id_range or {1, 65534}
	
	local sim = alife()
	local gg = game_graph()
	local id_list = {}
	args.enemy_to = args.enemy_to or db.actor
	local is_enemies = game_relations.is_factions_enemies	-- shortcut

	
	for id=id_range[1], id_range[2] do
		local object = sim:object(id)
		if object then
			-- THIS IS IT. Argument handler. Killing machine. Use comments to know what's going on
			if (name_set[object:section_name()] or has_ending_in_list(object, args.possible_endings)) and	-- name check
					((not args.in_world or not args.in_npc_inv) or				-- all items if args not given OR
					(args.in_world or not(object_in_world(object))) and			-- in_world items if argument given
					(args.in_npc_inv or not(object_in_npc_inventory(object)))) and	-- + npc items if argument given
					(not args.only_npc or object_in_npc_inventory(object)) and		-- - world items if only_npc
					(not args.only_enemies or is_enemies(get_community(args.enemy_to), get_community(sim:object(object.parent_id)))) and	-- only enemies check
					(not online_required or is_online(object, sim, gg)) and	-- online check
					(not nearby_required or is_nearby(object, sim, gg)) and	-- nearby check
					(with_blacklisted_maps or is_on_blacklisted_map(object, sim, gg))	-- blacklist check
					then -- then on new string for better git diff if new rule is added (please no)
				id_list[#id_list + 1] = id
				if first_item_only then return id_list end	-- I think this is clear
			end
		end
	end
end

function create_squad_at_smart(squad_data, smart)
	printf("GhenTuong: Start Function| create_squad_at_smart")
	local CACHE = {}
	printf("Igi: create_squad: %s", squad_data.name)
	local squad = alun_utils.create_squad(squad_data.name, smart)
	squad.stay_time = game.get_game_time()
	squad.force_online = true
	
	CACHE.id = squad.id
	CACHE.section_name = squad:section_name()
	return CACHE
end

function create_package(package_data, smart)		-- TODO
	printf("GhenTuong: Start Function| create_package")
	if not (package_data and smart) then printf("GhenTuong: not enought parameter") return end
	
	local package_obj_data = {}
	local smart_data = SIMBOARD.smarts_by_names[smart]
	local location = vector():set( --Make sure it don't fall under the ground
		smart_data.position.x,
		smart_data.position.y + 1,
		smart_data.position.z
	)
	local possible_content = package_data.possible_content	-- shortcut
	--Load content
	local content = ""
	for index = 1, package_data.amount_content do
		if (index > 1) then content = content .. "," end
		content = content .. possible_content[math.random(#possible_content)]
	end
	--Create package
	local created_object = alife():create(package_data.package_name, location, smart_data.m_level_vertex_id, smart_data.m_game_vertex_id)
	if created_object then
		local data = stpk_utils.get_item_data(created_object)
		data.visual_name = package_data.visual_name
		data.custom_data = content
		stpk_utils.set_item_data(data, created_object)
		
		package_obj_data = {
			id = created_object.id,
			section_name = created_object:section_name()
		}
	end
	return package_obj_data
end

function create_target(SETUP_CACHE, task_id)
	printf("Igi: create_target")
	local handlers = {
		["packages"] = create_package,
		["squads"] = create_squad_at_smart,
	}
	local target = {}
	local location = SETUP_CACHE.smarts[1]
	alun_utils.print_table(SETUP_CACHE, "SETUP_CACHE")
	
	for target_type, handler in pairs(handlers) do
		if SETUP_CACHE[target_type] then
			target[target_type] = {}
			for _, target_group_data in pairs(SETUP_CACHE[target_type]) do
				local group_cache = {}
				for i=1, target_group_data.amount do
					printf("TARGET: %s : %s", _, target_data)
					local obj_data = handler(target_group_data, location)
					group_cache[#group_cache + 1] = obj_data
				end
				target[target_type][#target[target_type] + 1] = group_cache
			end
		end
	end
	
	SETUP_CACHE["target"] = target
	utils.save_var(db.actor, task_id, SETUP_CACHE)
	return SETUP_CACHE
end

function get_faction_setup(--[[optional]] factions)	-- TODO: implement factions
	-- This function returns target character factions for all possible quests
	-- Quest by himself decides, which character(s) to use
	printf("GhenTuong: Start Function| get_faction_setup")
	
	local faction_list = {
		["actor"] = 'stalker',
		["task_giver"] = 'stalker',
		["client"] = 'stalker',		-- default value is 'stalker', will be changed if possible
		["enemy"] = 'stalker',
	}
	
	local task_giver = mob_trade.GetTalkingNpc()
	faction_list["task_giver"] = character_community(task_giver)
	faction_list["actor"] = character_community(db.actor)
	
	local player_enemies = get_faction_enemies(faction_list['actor'])
	local task_giver_enemies = get_faction_enemies(faction_list["task_giver"])
	
	-- set enemy - must be enemy for both player and task giver
	tmp_enemies = {}	
	for faction in pairs(player_enemies) do					-- search for enemies of both player and task giver
		if task_giver_enemies[faction] then
			tmp_enemies[#tmp_enemies + 1] = faction
		end
	end
	if (#tmp_enemies == 0) then printf("GhenTuong: player and task giver doesn't share enemies") end
	faction_list["enemy"] = tmp_enemies[math.random(#tmp_enemies)] or "stalker"
	
	-- set client - must be enemy for enemy and not enemy with task giver; can be player's faction
	local enemy_enemies = get_faction_enemies(faction_list["enemy"])
	tmp_enemies = {}
	for faction in pairs(enemy_enemies) do
		if(faction ~= faction_list["task_giver"] and task_giver_enemies[faction] == nil) then
			tmp_enemies[#tmp_enemies + 1] = faction
		end
	end
	if (#tmp_enemies == 0) then printf("GhenTuong: can't setup client") end
	faction_list["client"] = tmp_enemies[math.random(#tmp_enemies)] or "stalker"
	return faction_list
end

function pick_quest_goods(quest_type) -- check
	local possible_goods = gt_database.QUEST_TO_POSSIBLE_GOODS[quest_type]
	local goods_type = possible_goods[math.random(#possible_goods)]
	local goods = gt_database.PACKAGE[goods_type]
	return goods
end

local function setup_postpone_data(target, factions, smart_name)
	local CACHE = {}
	if target then
		CACHE["target"] = target
	end
	
	if factions then
		CACHE["faction"] = factions
	end
	
	if smart_name then
		CACHE["location"] = "st_" .. smart_name .. "_name"
	end
	return CACHE
end

function get_target_descript(postpone_data)
	local content = ""
	local function text_line(name, detail)
		return "%c[d_orange]" .. name .. ": " .. "%c[0,255,255,255]" .. detail
	end
	
	for k, v in pairs(postpone_data) do
		local label = game.translate_string(gt_database.TEXT_HEADER .. k)
		local details = ""
		
		if type(v) == "table" then		-- if value is list: add every item in list
			for key, value in pairs(v) do
				if key > 1 then details = details .. ', ' end
				details = details .. game.translate_string(value)
			end
		
		elseif k == "location" then details = game.translate_string(v)
		else details = game.translate_string(gt_database.TEXT_HEADER .. v) end
		
		local text = text_line(label, details)
		content = content .. text .. "\\n"
	end

	return content
end

function get_postpone_intel(quest_name, target_name, factions, smart_name)
	local postpone_data = setup_postpone_data(target_name, factions, smart_name)
	local postpone_intel = {
		caption = game.translate_string(gt_database.TEXT_HEADER .. quest_name .. "_title"),
		text = get_target_descript(postpone_data),		-- data is set in setup_postpone_data
		icon = gt_database.QUEST_INFO[quest_name].icon
	}
	return postpone_intel
end

function postpone_function(intel)
		db.actor:give_talk_message2(intel.caption, intel.text, intel.icon, "iconed_answer_item")
		return true
	end

function change_goodwill(faction, to_increase)		-- TODO: goodwill stats to db
	if not faction then return nil, "gt_goodwill: no faction given" end
	if to_increase then
		xr_effects.complete_task_inc_goodwill(a, b, {50, faction})
	else
		xr_effects.fail_task_dec_goodwill(a, b, {25, faction})
	end
end

function release_squad(squad_data)
	printf("GhenTuong: Start Function| release_squad")
	if not (squad_data.id) then printf("GhenTuong: no squad_data.id") return end
	if not (squad_data.section_name) then printf("GhenTuong: no squad_data.section_name") return end
	
	local squad = alife():object(squad_data.id)

	if not (squad) then return end
	if not (squad:clsid() == clsid.online_offline_group_s) then return end
	if not (squad:section_name() == squad_data.section_name) then return end
	
	printf("GhenTuong: release %s", squad:name())
	SIMBOARD:remove_squad(squad)
end

function count_release_loot(list)
	printf("GhenTuong: Start Function| package_loot_release")
	--Count how many is in player inventory
	--condition is a list of parent_id of the packages. Release if fitted. Must be a list.
	--condition == nil => only count how many package is in player inventory
	--AC_ID is player, 65535 is world map
	if not (list) then return end
	local count = 0
	for index, data in pairs(list) do
		local pick_package = alife():object(data.id)
		if (pick_package and (pick_package:section_name() == data.section_name)) then
			--Count how many is in player inventory
			if (pick_package.parent_id == AC_ID) then count = count + 1 end
			--Release if parent_id is fitted
			if (condition and (#condition > 0)) then
				for index, data in pairs(condition) do
					if (pick_package.parent_id == data) then
						printf("GhenTuong: release %s| parent_id = %s", pick_package:name(), pick_package.parent_id)
						safe_release_manager.release(pick_package)
					end
				end
			end
		end
	end
	--Remove mark
	local remove_mark = check_package(list, false)
	return count
end

function change_squad_faction(squad_id, faction)
	-- This can be used only on online objects
	local squad = alife():object(squad_id)
	for npc in squad:squad_members() do
		local member = npc and level.object_by_id(npc.id)
		if (member and not (character_community(member) == faction)) then
			printf("GhenTuong: %s| %s => %s", npc.object:name(), character_community(member), faction)
			member:set_character_community(faction, 0, 0)
		end
	end
end

local function check_package_in_world(package_obj, package_data)
	if not (package_obj) or  													--Doesn't exist
			not (package_obj:section_name() == package_data.section_name) or  	--section_name is not correct
			not (package_obj.parent_id == 65535) then							--Not in world map
		return false
	else return true end
end

function update_packages_mark(pkg_list)
	--Check if packages are in world map and mark(unmark) them in PDA
	--mark == true. Mark those packages that is still in the world map
	--True if one of them is still in world map.
	for _, data in pairs(pkg_list) do
		local package_obj = alife():object(data.id)
		
		if check_package_in_world(package_obj, data) then
			if (data.id and level.map_has_object_spot(data.id,"treasure_unique") == 0) then
				level.map_add_object_spot(data.id, "treasure_unique", game.translate_string(gt_database.TEXT_HEADER .. "pda_package"))
			end
		else
			if (data.id and level.map_has_object_spot(data.id,"treasure_unique") == 1) then
				level.map_remove_object_spot(data.id, "treasure_unique")
			end
		end
	end
end

function init_task_cache(task_id, local_cache, global_tasks_cache)
	if not (global_tasks_cache[task_id]) then 
		printf("GhenTuong: %s| Can not init in first run.", task_id) 
		return nil, "global_tasks_cache not initialised" 
	end
	local_cache = global_tasks_cache[task_id]
	utils.save_var(db.actor, task_id, local_cache)
	return local_cache
end

function package_loot_release(list, condition)
	printf("GhenTuong: Start Function| package_loot_release")
	--Count how many is in player inventory
	--condition is a list of parent_id of the packages. Release if fitted. Must be a list.
	--condition == nil => only count how many package is in player inventory
	--AC_ID is player, 65535 is world map
	if not list then return end
	local count = 0
	for index, data in pairs(list) do
		local pick_package = alife():object(data.id)
		if (pick_package and (pick_package:section_name() == data.section_name)) then
			--Count how many is in player inventory
			if (pick_package.parent_id == AC_ID) then count = count + 1 end
			--Release if parent_id is fitted
			if (condition and (#condition > 0)) then
				for index, data in pairs(condition) do
					if (pick_package.parent_id == data) then
						printf("GhenTuong: release %s| parent_id = %s", pick_package:name(), pick_package.parent_id)
						safe_release_manager.release(pick_package)
					end
				end
			end
		end
	end
	--Remove mark
	local remove_mark = update_packages_mark(list)
	return count
end

function reward_quest_money(task_name)
	local sum_money = gt_database.QUEST_INFO[task_name].reward
	local money = {tostring(sum_money), tostring(sum_money+1000)}
	xr_effects.reward_random_money(nil, nil, money)
end
