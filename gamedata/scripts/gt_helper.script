-- There are functions that are used by other complex functions

function alife_obj(id)
	id = tonumber(id)
	if not id then
		callstack()
		assert(nil, "Don't look at me, senpai >//////<")
	end
	return alife_object(id)
end

local ARTIFACT_NAMES = {}
function get_artifact_names()
	-- creates a set of all artifacts in game
	if next(ARTIFACT_NAMES) then return ARTIFACT_NAMES end	-- if set already created: return that set
	-- if set not created: create, save and return
	ARTIFACT_NAMES = {}
	local ini = ini_file("items\\settings\\artefacts.ltx")
	local n = ini:line_count("artefact_groups")
	for i=0,n-1 do -- for every artefact group:
		_, group_name = ini:r_line_ex("artefact_groups",i,"","")  -- write group id
		if ini:section_exist(group_name) then
			local m = ini:line_count(group_name)
			for j=0,m-1 do
				_, artifact_name = ini:r_line_ex(group_name,j,"","")
				if artifact_name and ini_sys:section_exist(artifact_name) then
					ARTIFACT_NAMES[#ARTIFACT_NAMES + 1] = artifact_name -- for every artifact in group: add it's id as key
					--printf("GhenTuong: load artifact: %s", artifact_id)
				else
					printf("GhenTuong: load artifact from artefacts.ltx| incorrect section name: %s", artifact_id)
				end
			end
		end
	end
	return ARTIFACT_NAMES
end

function get_player_tier()
	local player_rank = db.actor:character_rank()
	for tier, bounds in pairs(gt_database.QUEST_TIERS) do
		if player_rank >= bounds[1] and player_rank <= bounds[2] then
			return tier
		end
	end
	return "endgame"
end

function check_common_npc(id)
	--Parameter is correct | not world map | not player |
	local npc = id and (id ~= 65535) and (id ~= AC_ID) and alife():object(id)
	--Exist | is stalker | alive |
	if not (npc and IsStalker(nil,npc:clsid()) and npc:alive()) then return false end
	--section_name has "sim_default", not "zombied"
	if not (string.find(npc:section_name(),"sim_default") and (not string.find(npc:section_name(),"zombied"))) then return false end
	--I don't know what it is. Perhaps doesn't get special npc. Got from tasks_bounty.script line 77
	if not ((get_object_story_id(id) == nil) and (npc.group_id ~= 65535) and (get_object_story_id(npc.group_id) == nil)) then return false end
	--Squad
	local squad = get_object_squad(npc)
	if not (squad) then return false end
	--Smart
	local smart_id = squad.current_target_id
	local smrt = smart_id and SIMBOARD.smarts[smart_id]
	local smart = smrt and smrt.smrt
	local smart_name = smart and smart:name()
	--Fancy checking smart and squad
	if not (smart_name) then return false end
	if (simulation_objects.base_smarts[smart_name] == true) then return false end
	if (squad:get_script_target()) then return false end
	--[[
	printf("GhenTuong: check_common_npc: %s | %s | %s",npc:name(),squad:name(), smart_name)
	--]]
	return true
end

function get_community(character)
	if not character then return nil end
	
	if character == db.actor then
		return character_community(character)
	else
		return alife_character_community(character)
	end
end

function object_in_world(obj_id)
	if not obj_id then return end
	local obj = alife_obj(obj_id)
	return obj.parent_id == 65535
end

function object_in_npc_inventory(obj_id)
	if not obj_id then return end
	local obj = alife_obj(obj_id)
	if not obj then return end
	return check_common_npc(obj.parent_id)
end

function object_in_player_inventory(obj_data)
	local obj = alife_obj(obj_data.id)
	if not obj then return end
	return obj.parent_id == 0
end

function get_object_level_id(obj)
	-- obj must be alife object
	if not obj then return nil end
	
	local lvl_info_obj
	if object_in_world(obj.id) then
		lvl_info_obj = obj
	elseif object_in_npc_inventory(obj.id) then
		lvl_info_obj = alife_obj(obj.parent_id)
	end
	
	local obj_level_id = game_graph():vertex(lvl_info_obj.m_game_vertex_id):level_id()
	return obj_level_id
end

function get_object_level(obj, sim, gg)
	return alife():level_name(get_object_level_id(object))
end

function get_faction_enemies(faction, --[[optional]] monolith_included)
	monolith_included = monolith_included or false
	local enemies_set = {}
	
	for enemy_faction in pairs(gt_database.GUARD_SQUAD) do
		if (game_relations.is_factions_enemies(faction, enemy_faction)) then
			if (enemy_faction ~= "monolith" or monolith_included) then
				enemies_set[enemy_faction] = true
			end
		end
	end
	return enemies_set
end

function check_smarts(smarts_table, --[[optional]] nearby_req, --[[optional]] online_req)
	-- This function checks table of smarts for
	-->	- availability
	-->	- smart is not a base
	--> - smart is not in blacklisted_maps
	--> - (optional) online and on level of player (nearby)
	-- and returns a table of suitable smarts
	assert(type(smarts_table) == 'table', 'gt: check_smarts: not a table given')
	local return_list = {}
	
	for smart_name, smart_data in pairs(smarts_table) do
		if simulation_objects.available_by_id[smart_data.id] and	-- availability check
				not simulation_objects.base_smarts[smart_name] then	-- base smart check
			local smart_level = alife():level_name(game_graph():vertex(smart_data.m_game_vertex_id):level_id())
			
			if not gt_database.BLACKLISTED_MAPS[smart_level] and not smart_data.squads then						-- blacklist check
				local is_online = smart_data.online
				local is_nearby = string.find(simulation_objects.config:r_value(level.name(), "target_maps", 0, ""), smart_level)
				
				if (nearby_req == nil and online_req == nil) or		-- any OR
						((nearby_req and online_req) and (is_online or is_nearby)) or	-- nearby + online OR
						(not is_nearby == not nearby_req) and 		-- specified
						(not is_online == not online_req) then		-- not is used to convert to boolean
					return_list[#return_list + 1] = smart_name
				end
			end
		end
	end
	return return_list
end

function is_online(object)
	player_level_id = get_object_level_id(db.player)
	object_level_id = get_object_level_id(object)
	return player_level_id == object_level_id
end

function is_nearby(object)
	local level = get_object_level(object)
	return string.find(simulation_objects.config:r_value(level.name(), "target_maps", 0, ""), level)
end

function is_on_blacklisted_map(object, sim, gg)
	object_lvl = get_object_level(object, sim, gg)
	if gt_database.BLACKLISTED_MAPS[object_lvl] then return true
	else return false end
end

function has_ending_in_list(object, ending_list)
	if not ending_list then return nil end
	local sec = object:section_name()
	
	for _, ending in pairs(ending_list) do
		if string.find(sec, ending) then
			return true end
	end
	return false
end

function check_object_by_args(args, se_object)
	assert((args.in_npc_inv and not args.in_world) or not args.enemy_to, 
			"Igi: Check object: enemy but not in_npc_inv")
	
	if args.in_world and object_in_npc_inventory(se_object.id) or
			args.in_npc_inv and object_in_world(se_object.id) then
		return false 
	end
	
	if object_in_npc_inventory(se_object.id) and args.only_enemies and
			not game_relations.is_factions_enemies(
					get_community(args.enemy_to), get_community(alife_obj(se_object.parent_id))) then
		return false
	end
	
	if args.is_online and not is_online(se_object) then
		return false 
	end
	
	if args.is_nearby and not is_nearby(se_object) then
		return false
	end
	alun_utils.print_table(args, se_object:section_name())
	printf(se_object:section_name() .. ' parent: ' .. tostring(se_object.parent_id) .. "in_npc: " .. tostring(object_in_npc_inventory(se_object.id)))
	return true
end

function find_objects_ids(name_set, args)
	--[[ Well, this big horse shit function finds all objects, which names are in name_set (must be set)
			Possible args:
		nearby_required (bool) - search for objects that are on player's nearby levels
		online_required (bool) - search for objects that are online
		possible endings (list of strings) - search for objects which name ends with one of these strings
		in_npc_inv (bool) - search in npc's inventories
		only_enemies (bool) - if in_npc_inv: only in enemies's inventories
	]]
	assert(next(name_set) ~= nil, "gt: find_objects_ids: no name set given")
	local id_list = {}	

	for id=1, 65534 do
		local obj = alife_obj(id)
		if obj then
			if name_set[obj:section_name()] or has_ending_in_list(obj, args.endings_list) then
				printf("Found: %s ", obj:section_name())
				if check_object_by_args(args, obj) then
					printf("Igi: Found one! %s", obj:section_name())
					id_list[#id_list + 1] = id
				end
			end
		end
	end

	return id_list
end

function create_squad_at_smart(squad_data, smart)
	local CACHE = {}
	local squad = alun_utils.create_squad(squad_data.name, smart)
	squad.stay_time = game.get_game_time()
	squad.force_online = true
	squad.scripted_target = smart
	
	CACHE.id = squad.id
	CACHE.section_name = squad:section_name()
	CACHE.location = smart
	return CACHE
end

function create_package(package_data, smart)
	if not (package_data and smart) then printf("GhenTuong: not enought parameter") return end
	
	local package_obj_data = {}
	local smart_data = SIMBOARD.smarts_by_names[smart]
	local location = vector():set( --Make sure it don't fall under the ground
		smart_data.position.x,
		smart_data.position.y + 1,
		smart_data.position.z
	)
	local possible_content = package_data.possible_content	-- shortcut
	--Load content
	local content = ""
	for index = 1, package_data.amount_content do
		if (index > 1) then content = content .. "," end
		content = content .. possible_content[math.random(#possible_content)]
	end
	--Create package
	local created_object = alife():create(package_data.package_name, location, smart_data.m_level_vertex_id, smart_data.m_game_vertex_id)
	assert(created_object, "Igi: impossible to create package")
	
	local data = stpk_utils.get_item_data(created_object)
	data.visual_name = package_data.visual_name
	data.content = content
	stpk_utils.set_item_data(data, created_object)
	
	package_obj_data = {
		id = created_object.id,
		section_name = created_object:section_name()
	}
	return package_obj_data
end

function create_item(item_data, smart)
	if item_data.id then
		item_data.section_name = alife_obj(item_data.id):section_name()
		return item_data
	end
end

function create_target(CACHE)
	local handlers = {
		["packages"] = create_package,
		["squads"] = create_squad_at_smart,
		["items"] = create_item,
	}
	local target = {}
	local location = CACHE.smarts[1]	-- TODO
	
	for target_type, handler in pairs(handlers) do
		if CACHE.setup[target_type] then
			target[target_type] = {}
			for _, target_group_data in pairs(CACHE.setup[target_type]) do
				local group_cache = {}
				for i=1, target_group_data.amount or 1 do
					local obj_data = handler(target_group_data, location)
					obj_data.custom_args = target_group_data.custom_args
					obj_data.target = target_group_data.target
					obj_data.online_activities = target_group_data.online_activities
					group_cache[#group_cache + 1] = obj_data
				end
				target[target_type][#target[target_type] + 1] = group_cache
			end
		end
	end
	
	CACHE["target"] = target
	return CACHE
end

function get_faction_setup(--[[optional]] factions)	-- TODO: implement factions
	-- This function returns target character factions for all possible quests
	-- Quest by himself decides, which character(s) to use
	
	local faction_list = {
		["actor"] = 'stalker',
		["task_giver"] = 'stalker',
		["client"] = 'stalker',		-- default value is 'stalker', will be changed if possible
		["enemy"] = 'stalker',
	}
	
	local task_giver = mob_trade.GetTalkingNpc()
	faction_list["task_giver"] = character_community(task_giver)
	faction_list["actor"] = character_community(db.actor)
	
	local player_enemies = get_faction_enemies(faction_list['actor'])
	local task_giver_enemies = get_faction_enemies(faction_list["task_giver"])
	
	-- set enemy - must be enemy for both player and task giver
	tmp_enemies = {}	
	for faction in pairs(player_enemies) do					-- search for enemies of both player and task giver
		if task_giver_enemies[faction] then
			tmp_enemies[#tmp_enemies + 1] = faction
		end
	end
	if (#tmp_enemies == 0) then printf("GhenTuong: player and task giver doesn't share enemies") end
	faction_list["enemy"] = tmp_enemies[math.random(#tmp_enemies)] or "stalker"
	
	-- set client - must be enemy for enemy and not enemy with task giver; can be player's faction
	local enemy_enemies = get_faction_enemies(faction_list["enemy"])
	tmp_enemies = {}
	for faction in pairs(enemy_enemies) do
		if(faction ~= faction_list["task_giver"] and task_giver_enemies[faction] == nil) then
			tmp_enemies[#tmp_enemies + 1] = faction
		end
	end
	if (#tmp_enemies == 0) then printf("GhenTuong: can't setup client") end
	faction_list["client"] = tmp_enemies[math.random(#tmp_enemies)] or "stalker"
	return faction_list
end

function pick_quest_goods(quest_type) -- check
	local possible_goods = gt_database.QUEST_TO_POSSIBLE_GOODS[quest_type]
	local goods_type = possible_goods[math.random(#possible_goods)]
	local goods = gt_database.PACKAGE[goods_type]
	return goods
end

local function setup_postpone_data(target, factions, smart_name)
	local CACHE = {}
	if target and target[1] then
		CACHE["target"] = target
	end
	
	if factions and factions[1] then
		CACHE["faction"] = factions
	end
	
	if smart_name then
		CACHE["location"] = "st_" .. smart_name .. "_name"
	end
	return CACHE
end

function get_target_descript(postpone_data)
	local content = ""
	local function text_line(name, detail)
		return "%c[d_orange]" .. name .. ": " .. "%c[0,255,255,255]" .. detail
	end
	
	for k, v in pairs(postpone_data) do
		local label = game.translate_string(gt_database.TEXT_HEADER .. k)
		local details = ""
		
		if type(v) == "table" then		-- if value is list: add every item in list
			for key, value in pairs(v) do
				if key > 1 then details = details .. ', ' end
				details = details .. game.translate_string(value)
			end
		else details = game.translate_string(v) end

		local text = text_line(label, details)
		content = content .. text .. "\\n"
	end

	return content
end

function get_postpone_intel(quest_name, targets, factions, smart_name)
	local postpone_data = setup_postpone_data(targets, factions, smart_name)
	local postpone_intel = {
		caption = game.translate_string(gt_database.TEXT_HEADER .. quest_name .. "_title"),
		text = get_target_descript(postpone_data),		-- data is set in setup_postpone_data
		icon = igi_quests.QUEST_INFO[quest_name].icon
	}
	return postpone_intel
end

function postpone_function(intel)
		db.actor:give_talk_message2(intel.caption, intel.text, intel.icon, "iconed_answer_item")
		return true
	end

function change_goodwill(faction, task_name, task_successful)
	if not faction then return nil, "gt_goodwill: no faction given" end
	local value = task_successful and (igi_quests.QUEST_INFO[task_name].reward_goodwill or 50) or -50 
	if value > 0 then
		xr_effects.complete_task_inc_goodwill(a, b, {value, faction})
	else
		xr_effects.fail_task_dec_goodwill(a, b, {value, faction})
	end
end

function release_squad(squad_data)
	if not (squad_data.id) then printf("GhenTuong: no squad_data.id") return end
	if not (squad_data.section_name) then printf("GhenTuong: no squad_data.section_name") return end
	
	local squad = alife_obj(squad_data.id)

	if not (squad) then return end
	if not (squad:clsid() == clsid.online_offline_group_s) then return end
	if not (squad:section_name() == squad_data.section_name) then return end
	
	printf("GhenTuong: release %s", squad:name())
	SIMBOARD:remove_squad(squad)
end

function change_squad_faction(squad_id, faction)
	-- This can be used only on online objects
	local squad = alife_obj(squad_id)
	for npc in squad:squad_members() do
		local member = npc and level.object_by_id(npc.id)
		if member and not (character_community(member) == faction) then
			printf("GhenTuong: %s| %s => %s", npc.object:name(), character_community(member), faction)
			member:set_character_community(faction, 0, 0)
		end
	end
end

local function check_package_in_world(package_obj, package_data)
	if not (package_obj) or  													--Doesn't exist
			not (package_obj:section_name() == package_data.section_name) or  	--section_name is not correct
			not (package_obj.parent_id == 65535) then							--Not in world map
		return false
	else return true end
end

function update_mark(obj_data, mark_type)
	local obj = alife_obj(obj_data.id)
	
	if check_package_in_world(obj, obj_data) then
		if (obj_data.id and level.map_has_object_spot(obj_data.id, mark_type) == 0) then
			level.map_add_object_spot(obj_data.id, mark_type, game.translate_string(gt_database.TEXT_HEADER .. mark_type))
		end
	elseif not check_package_in_world(obj, obj_data) then
		if (obj_data.id and level.map_has_object_spot(obj_data.id, mark_type) == 1) then
			level.map_remove_object_spot(obj_data.id, mark_type)
		end
	end
end

function release_package(pkg_data)
	if not pkg_data then return end
	
	local pkg = alife_obj(pkg_data.id)
	if (pick_package and (pkg:section_name() == data.section_name)) then
		printf("GhenTuong: release %s| parent_id = %s", pkg:name(), pkg.parent_id)
		safe_release_manager.release(pkg)
	end
end

function reward_quest_money(task_name)
	local difficulty_addition = {
		['start_game'] = 0,
		['midgame'] = 2000,
		['endgame'] = 4000,
	}
	local sum_money = igi_quests.QUEST_INFO[task_name].reward_money
	if sum_money == 0 then return end
	
	local player_tier = get_player_tier()

	if (not sum_money) and player_tier then
		sum_money = 2500 + difficulty_addition[player_tier]
	elseif not sum_money then
		sum_money = 2500
	end

	local money = {tostring(sum_money), tostring(sum_money+1000)}
	xr_effects.reward_random_money(nil, nil, money)
end

function release_targets_in_world(target_cache)
	local handlers = {
		['packages'] = release_package,
		['squads'] = release_squad,
	}
	
	for name, handler in pairs(handlers) do
		if target_cache[name] then
			for _, target_group in pairs(target_cache[name]) do
				for _, target_data in pairs(target_group) do
					printf("Release %s: name: %s, id: %s", name, target_data.section_name, target_data.id)
					handler(target_data)
				end
			end
		end
	end
end

function quest_target(CACHE)
	if not CACHE.win_conditions or 
			not(CACHE.win_conditions.instant and CACHE.win_conditions.continuous) then
		return end

	_, target_obj = next(CACHE.win_conditions.instant)
	if not target_obj then
		for _, objective_data in pairs(CACHE.win_conditions.continuous) do
			-- If ready_functor exist and is task is not ready => do it
			target_obj = objective_data.ready_functor and not objective_data.ready_functor(objective_data) and objective_data
			if target_obj then break end
		end
	end
	return target_obj and target_obj.id
end

function update_marks(CACHE)
	local marks = {
		["packages"] = "treasure_unique",
		["item"] = "item_misc",
	}
	for typ, mark_type in pairs(marks) do
		if CACHE.target[typ] then
			for _, obj_group in pairs(CACHE.target[typ]) do
				for _, obj_data in pairs(obj_group) do
					update_mark(obj_data, mark_type)
				end
			end
		end
	end
end

function change_squad_role(squad_data, role, CACHE)
	if not CACHE.factions[role] and not gt_database.GUARD_SQUAD[role] then
		printf("IGI: change role: role unknown")
		return
	end
	if type(role) == table then
		printf("Igi: role is table")
		_, role = next(role)
	end
	role = CACHE.factions[role] or role		-- if role is not in CACHE => role is actual faction
	change_squad_faction(squad_data.id, role)
end

function is_npc_online(id)
    for i,v in ipairs(db.OnlineStalkers) do 
        if (v == id) then 
            return true
        end
    end
end

function is_squad_member_online(se_squad)
	for k in se_squad:squad_members() do
		return is_npc_online(k.id)
	end
end

function repair_item(item_data, arg, CACHE)
	local item = alife_obj(item_data.id)
	if item and item:condition() < 0.9 then
		item:set_condition(math.random(90,100)/100)
	end
end

function do_online_activities(CACHE)
	if not CACHE.online_activities then return CACHE, false end
	local condition_handlers = {
	}
	
	local action_handlers = {
		['change_faction'] = change_squad_role,
		['repair'] = repair_item,
	}
	local is_changed = false
	for condition, objects in pairs(CACHE.online_activities) do
		for k, obj_data in pairs(objects) do
			se_squad = alife_obj(obj_data.id)
			-- Check for first member online, I don't give a fuck if some of them are offline
			if is_squad_member_online(se_squad) then
				-- If condition is true
				if condition == "is_online" or condition_handlers[condition](obj_data, CACHE) then
					-- Do every activity with this condition
					for action, args in pairs(obj_data.online_activities[condition]) do
						if action_handlers[action] then
							action_handlers[action](obj_data, args, CACHE)
						end
					end
					-- Delete object after activity is done
					objects[k] = nil
					is_changed = true
				end
			end
		end
		-- delete activities if there's no more objects
		if not next(objects) then CACHE.online_activities[condition] = nil end
	end
		-- delete the whole section
	if not next(CACHE.online_activities) then CACHE.online_activities = nil end
	return CACHE, is_changed
end

function gt_object_exist(obj_data)
	local obj = alife_obj(obj_data.id)
	return obj and obj:section_name() == obj_data.section_name
end

function gt_object_not_exist(obj_data)
	return not gt_helper.gt_object_exist(obj_data)	-- Idk but it can't see object_exist or even gt_object_exist. Fuck lua.
end

function gt_object_in_player_inv(obj_data)
	local obj = alife_obj(obj_data.id)
	return obj and obj.parent_id == 0
end

function deliver_item(obj_data)
	local npc = mob_trade.GetTalkingNpc()
	if npc then
		dialogs.relocate_item_section_from_actor(db.actor, npc, obj_data.section_name, 1)
	else
		local item = db.actor:object(obj_data.section_name)
		local se_item = item and alife_obj(item:id())
		if se_item then
			alife():release(se_item,true)
		end
	end
end

function sort_win_conditions(CACHE)
	local instant_objective = {
		["kill"] = gt_object_not_exist,
		["get"] = gt_object_in_player_inv,
	}
	-- function for task to not fail, 
	-- function to call on quest finish,
	-- function to check if task is ready to finish,
	-- (optional) function to call on quest fail
	local continuous_objective = {
		["return"] = {gt_object_exist, deliver_item, object_in_player_inventory},
	}
	local instant = {}
	local continuous = {}
	for k, condition_data in pairs(CACHE.win_conditions) do
		local target = condition_data.target
		if instant_objective[target] then
			condition_data.functor = instant_objective[target]
			instant[#instant + 1] = condition_data
		elseif continuous_objective[target] then
			condition_data.functor = continuous_objective[target][1]
			condition_data.finish_function = continuous_objective[target][2]
			condition_data.ready_functor = continuous_objective[target][3]
			condition_data.fail_function = continuous_objective[target][4]
			continuous[#continuous + 1] = condition_data
		end
		condition_data.target = nil
		CACHE.win_conditions[k] = nil
	end
	
	CACHE.win_conditions["instant"] = instant
	CACHE.win_conditions["continuous"] = continuous
	return CACHE
end

function setup_win_condition(CACHE)
	local conditions = {}
	for _, groups in pairs(CACHE.target) do
		for _, group in pairs(groups) do
			for _, item in pairs(group) do
				if item.target then
					conditions[#conditions + 1] = item
				end
			end
		end
	end
	CACHE.win_conditions = conditions
	CACHE = sort_win_conditions(CACHE)
	return CACHE
end

function process_objectives(CACHE)
	-- Instant = instant without completed tasks
	local temp_instant = {}
	local is_changed = false
	for k, objective_data in pairs(CACHE.win_conditions.instant) do
		if not objective_data.functor(objective_data) then
			temp_instant[#temp_instant + 1] = objective_data
		else is_changed = true end
	end
	CACHE.win_conditions.instant = is_changed and temp_instant or CACHE.win_conditions.instant
	return CACHE, is_changed
end

function check_continuous_failed(CACHE)
	-- Returns true, if all continuous objectives are ready;
	-- Returns false, if at least one condition is failed;
	-- Continuous objectives will be completed with task end and can be failed

	local continuous_conditions = CACHE.win_conditions.continuous
	-- If functor of continuous not true - mission fail
	for k, objective_data in pairs(continuous_conditions) do
		if not objective_data.functor(objective_data) then
			return true
		end
	end
	return false
end

function check_continuous_running(CACHE)
	local continuous_conditions = CACHE.win_conditions.continuous
	-- If functor of continuous not true - mission fail
	for k, objective_data in pairs(continuous_conditions) do
		if not (objective_data.ready_functor and objective_data.ready_functor(objective_data)) then
			return true
		end
	end
	return false
end

function finish_continuous_objectives(CACHE, is_complete)
	for _, objective_data in pairs(CACHE.win_conditions.continuous) do
		if is_complete then objective_data.finish_function(objective_data)
		elseif not is_complete and objective_data.fail_function then
			objective_data.fail_function(objective_data)
		end
	end
end

function sort_online_activities(CACHE)
	-- Adds all objects with online activities to CACHE
	-- CACHE.online_activities = {*condition* = {*list of obj_data*}}
	local online_acts = {}
	for _, typ in pairs(CACHE.target) do
		for _, group in pairs(typ) do
			for _, obj_data in pairs(group) do
				if obj_data.online_activities then
					for condition, actions in pairs(obj_data.online_activities) do
						if not online_acts[condition] then online_acts[condition] = {} end
						online_acts[condition][#online_acts[condition] + 1] = obj_data
					end
				end
			end
		end
	end
	CACHE.online_activities = online_acts
	return CACHE
end

function clear_smart(smart_name)
	xr_effects.clear_smart_terrain(nil, nil, {smart_name,})
end

function clear_smarts(CACHE)
	for _, smart_name in pairs(CACHE.smarts) do
		clear_smart(smart_name)
	end
end

function rank_precondition(tier)
	assert(gt_database.QUEST_TIERS[tier] or ranks.stalker_rank_intervals[tier],
			"Igi: Invalid quest tier")
			
	if gt_database.QUEST_TIERS[tier] then
		lower_bound = gt_database.QUEST_TIERS[tier][1]
		higher_bound = gt_database.QUEST_TIERS[tier][2]
	elseif ranks.stalker_rank_intervals[tier] then
		lower_bound = ranks.stalker_rank_intervals[tier][1]
		higher_bound = ranks.stalker_rank_intervals[tier][2]
	end
	local player_rank = db.actor:character_rank()
	return player_rank >= lower_bound and player_rank <= higher_bound
end

function goodwill_precondition(arg)
	local task_giver = mob_trade.GetTalkingNpc()
	local community = character_community(task_giver)
	return db.actor:community_goodwill(community) >= arg
end

function scale_to_rank(tbl)
	local player_tier = get_player_tier()
    for k, v in pairs(tbl) do
        if type(v) == 'table' then
            tbl[k] = scale_to_rank(v)
        elseif type(v) == 'string' and string.find(v, "scalable") then
            tbl[k] = string.gsub(v, "scalable", player_tier)
        end
    end
    return tbl
end











