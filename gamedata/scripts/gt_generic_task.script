-- =============================================================
--	Quest functions (gt_generic_task.script)
--	Anomaly 1.5.5.0
--	Igigog
-- =============================================================
local SETUP_TASK_CACHE = {} --CACHE to setup task

--< Effect >--------------------------------------------------
xr_effects.gt_task_generic_setup = function(actor,npc,p)	-- check
	--This function will be called on_job_descr
	--p[1] is task id
	--p[2] is task name
	if not (p and p[1] and p[2]) then return false end
	--Setup
	local task_id = p[1]
	local task_name = p[2]
	local CACHE = {}

	if not SETUP_TASK_CACHE[task_id] then
		CACHE = gt_setup.setup_quest(igi_quests.CONSTRUCTOR(task_name))
		CACHE['task_name'] = task_name
		SETUP_TASK_CACHE[task_id] = CACHE
	else CACHE = SETUP_TASK_CACHE[task_id] end

	--Give message
	local postpone_intel = gt_helper.get_postpone_intel(task_name, CACHE.desc_targets,
												CACHE.desc_factions, CACHE.desc_smarts[1])
	--Print the message
	CreateTimeEvent(0, "gt_task_"..quest_name.."_setup", 0, gt_helper.postpone_function, postpone_intel)
end
--< Status >--------------------------------------------------
task_status_functor.gt_task_generic_status = function (tsk,task_id)

	if not (db.actor and tsk) then return end
	
	local CACHE = utils.load_var(db.actor, task_id)
	if (tsk.stage == 1) then					-- TODO: Multi-stage quests
		return
	end --completed
	
	--First run. Init task
	if not CACHE then
		CACHE, err = gt_helper.init_task_cache(task_id, CACHE, SETUP_TASK_CACHE)
		if err then return "fail" end
	end
	--Create target
	if not (CACHE["target"]) then
		CACHE = gt_helper.create_target(CACHE)
		CACHE = gt_helper.setup_win_condition(CACHE)		-- TODO
		gt_helper.mark_targets(CACHE)
	end
	
	gt_helper.do_online_activities(CACHE)
	
	quest_done = gt_helper.check_win_condition(CACHE)		-- TODO
	if quest_done ~= nil then
		if quest_done then
			tsk.stage = 1
		else
			return "fail"
		end
	end

end
--< Target >--------------------------------------------------
task_functor.gt_task_generic_target = function(task_id,field,p,tsk)	-- check
	--This function point to a task target in PDA
	if not (db.actor and tsk) then return end
	if (tsk.stage == 1 and tsk.task_giver_id) then return tsk.task_giver_id end		-- TODO: multi-stage quests
	local CACHE = utils.load_var(db.actor, task_id)
	if not (CACHE) then return end
	return gt_helper.quest_target(CACHE)
end
--< Text >--------------------------------------------------
task_functor.gt_task_generic_text = function(task_id,field,p,tsk)	-- check
	--This function return a text for title_functor and descr_functor
	if not (db.actor) then return "" end
	local CACHE = utils.load_var(db.actor,task_id)
	if (field == "title") then
		return game.translate_string(gt_database.TEXT_HEADER .. CACHE.task_name .. "_title")
	elseif (field == "descr") then
		if not (CACHE) then return "" end
		local text = ""
		if (tsk.stage == 1) then
			text = game.translate_string(gt_database.TEXT_HEADER .. "done")
		else
			text = game.translate_string(gt_database.TEXT_HEADER .. CACHE.task_name .. "_descr")
		end
		local description = gt_helper.get_postpone_intel(CACHE.task_name, CACHE.description.targets,
												CACHE.description.factions, CACHE.description.smarts[1]).text
		return (text .. "\\n " .. description) or ""
	end
end
--< Reward >--------------------------------------------------
xr_effects.gt_task_generic_finish = function(actor,npc,p)	-- check
	if not (p and p[1] and p[2]) then return end
	local task_id = p[1]
	local is_completed = p[2]
	local CACHE = utils.load_var(db.actor, task_id)
	--Reward money
	if is_completed then 
		gt_helper.reward_quest_money(CACHE.task_name)
		xr_effects.inc_task_stage(a, b, {task_id})
	end
	--Goodwill
	gt_helper.change_goodwill(CACHE.factions.task_giver, is_completed)
	--Release
	gt_helper.release_targets(CACHE.targets)
	gt_helper.unmark_targets(CACHE)
	--Reset stored data
	utils.save_var(db.actor, task_id, nil)
	--Finish
	xr_effects.drx_sl_unregister_task_giver(a, b, {task_id})
	xr_effects.drx_sl_reset_stored_task(a, b, {task_id})
end