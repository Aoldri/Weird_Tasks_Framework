-- =============================================================
--	Quest function (gt_task_transaction.script)
--	Anomaly 1.5.5.0
--	GhenTuong
-- =============================================================
local SETUP_TASK_CACHE = {} --CACHE to setup task
--SETUP_TASK_CACHE[task_id] = {
--	["setup"]
--	["smart"]
--	}
-- =============================================================

local function init_cache(task_id, local_cache)
	if not (SETUP_TASK_CACHE[task_id]) then 
		printf("GhenTuong: %s| Can not init in first run.", task_id) 
		return nil, "SETUP_TASK_CACHE not initialised" 
	end
	CACHE = SETUP_TASK_CACHE[task_id]
	utils.save_var(db.actor, task_id, CACHE)
	return CACHE
end



--< Effect >--------------------------------------------------
xr_effects.gt_task_transaction_setup = function(actor,npc,p)	-- check?
	--This function will be called on_job_descr
	--p[1] is task id
	if not (p and p[1]) then return false end
	--Setup
	local task_id = p[1]
	local CACHE = {}

	if not SETUP_TASK_CACHE[task_id] then
		CACHE = gt_setup.setup_quest({
									['smarts'] = {['is_nearby'] = true},
									['squads'] = {
										{['type'] = 'guard',
										['faction_type'] = 'client'},

										{['type'] = 'guard',
										['faction_type'] = 'enemy'},
									},
									['packages'] = {
										{['quest_type'] = 'transaction',},
									},
								})
		SETUP_TASK_CACHE[task_id] = CACHE
	else CACHE = SETUP_TASK_CACHE[task_id] end

	--Give message
	local postpone_intel = gt_helper.get_postpone_intel('transaction', CACHE.packages[1].package_type,		-- first package of first type of packages
												{CACHE.squads[1].faction, CACHE.squads[2].faction}, CACHE.smarts[1])
	--Print the message
	CreateTimeEvent(0, "gt_task_transaction_setup", 0, gt_helper.postpone_function, postpone_intel)
end
--< Status >--------------------------------------------------
task_status_functor.gt_task_transaction_status = function (tsk,task_id)	-- check

	if not (db.actor and tsk) then return end
	
	local CACHE = utils.load_var(db.actor, task_id)
	if (tsk.stage == 1) then
		--Mark packages in PDA
		local check = gt_helper.update_packages_mark(CACHE["target"].packages[1])
		return
	end --completed
	
	--First run. Init task
	if not CACHE then
		CACHE, err = gt_helper.init_task_cache(task_id, CACHE, SETUP_TASK_CACHE)
		if err then return "fail" end
	end
	--Create target
	if not (CACHE["target"]) then
		CACHE = gt_helper.create_target(CACHE, task_id)
	end
	--Mark packages in PDA
	gt_helper.update_packages_mark(CACHE.target.packages[1])
	
	--Check if target is alive
	local target_squad = alife():object(CACHE.target.squads[1][1].id)
	local squad_info = CACHE.target.squads[1][1]	-- shortcut
	local target_is_alive = target_squad and (target_squad:section_name() == squad_info.section_name)
	if not (target_is_alive) then
		tsk.stage = 1
	
	end

end
--< Target >--------------------------------------------------
task_functor.gt_task_transaction_target = function(task_id,field,p,tsk) -- check
	--This function point to a task target in PDA
	if not (db.actor and tsk) then return end
	if (tsk.stage == 1 and tsk.task_giver_id) then return tsk.task_giver_id end
	local CACHE = utils.load_var(db.actor, task_id)
	if not (CACHE) then return end
	return CACHE.target.squads[1][1].id
end
--< Text >--------------------------------------------------
task_functor.gt_task_transaction_text = function(task_id,field,p,tsk)	-- check
	--This function return a text for title_functor and descr_functor
	if not (db.actor) then return "" end
	if (field == "title") then
		return game.translate_string(gt_database.TEXT_HEADER .. 'transaction_' .. "title")
	elseif (field == "descr") then
		local CACHE = utils.load_var(db.actor,task_id)
		if not (CACHE) then return "" end
		local text = ""
		if (tsk.stage == 1) then
			text = game.translate_string(gt_database.TEXT_HEADER .. "done")
		else
			text = game.translate_string(gt_database.TEXT_HEADER .. "transaction" .. "_descr")
		end
		local description = gt_helper.get_postpone_intel('transaction', CACHE.packages[1].package_type,		-- first package of first type of packages
												{CACHE.squads[1].faction, CACHE.squads[2].faction}, CACHE.smarts[1]).text
		return (text .. "\\n " .. description) or ""
	end
end
--< Reward >--------------------------------------------------
xr_effects.gt_task_transaction_finish = function(actor,npc,p)	-- TODO
	if not (p and p[1] and p[2]) then return end
	local task_id = p[1]
	local is_completed = p[2]
	local CACHE = utils.load_var(db.actor, task_id)
	--Reward money
	if is_completed then 
		gt_helper.reward_quest_money("transaction")
		xr_effects.inc_task_stage(a, b, {task_id})
		end
	--Goodwill
	if CACHE["task_giver_faction"] then
		gt_helper.change_goodwill(CACHE.factions.task_giver, is_completed)
	end
	--Release
	gt_helper.package_loot_release(CACHE.target.packages[1], {65535})
	printf(CACHE.target.squads[1][1])
	printf(CACHE.target.squads[1])
	printf(CACHE.target.squads)
	gt_helper.release_squad(CACHE.target.squads[1][1])
	gt_helper.release_squad(CACHE.target.squads[2][1])
	--Reset stored data
	utils.save_var(db.actor, task_id, nil)
	--Finish
	xr_effects.drx_sl_unregister_task_giver(a, b, {task_id})
	xr_effects.drx_sl_reset_stored_task(a, b, {task_id})
end