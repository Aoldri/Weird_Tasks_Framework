local trace_dbg = igi_helper.trace_dbg
local trace_assert = igi_helper.trace_assert

function broadcast_entity(entities, entity)
	for k,v in pairs(entities) do
		if type(v) == 'string' and not string.find(k, "link") then
			entities[k] = resolve_dependencies(v, entity)
		elseif type(v) == 'table' then
			broadcast_entity(v, entity)
		end
	end
end

function set_missing_group_ids(entities)
	local counters = count_entity_types(entities)
	for _, entity in pairs(entities) do
		if not entity.group_id then
			counters[entity.entity_type] = counters[entity.entity_type] + 1
			entity.group_id = counters[entity.entity_type]
		end
	end
end

function count_entity_types(entities)
	local counters = igi_utils.defaultdict(0)
	for _, entity in pairs(entities) do
		local counter = counters[entity.entity_type]
		if entity.group_id and (entity.group_id > counter) then
			counters[entity.entity_type] = entity.group_id
		end
	end
	return counters
end

function has_no_outer_links(tbl, entity)
	for k,v in pairs(tbl) do
		if type(v) == 'string' and not string.find(k, "link") then
			for k2 in dependency_iterator(v) do
				if not Link.from(k2, entity):is_pointed_to(entity) then
					return false
				end
			end
		elseif type(v) == 'table' and not has_no_outer_links(v, entity) then
			return false
		end
	end
	return true
end

Link = {
	__cls = 'Link',

	new = function (self, typ, group_id, entity_id, field)
		local t = {
			type = typ,
			group_id = tonumber(group_id) or 1,
			entity_id = tonumber(entity_id) or 1,
			field = field ~= "" and field or "id",
		}
		return setmetatable(t, {__index = Link})
	end,

	from = function (str, this_entity)
		-- Won't work with dependencies with macros
		trace_assert(type(str) == "string", str)

		local pattern = "%$([^_%.]+)_?([^_%.]*)_?([^_%.]*)%.?(.-)%$"
		local typ, group_id, entity_id, field = str:match(pattern)
		trace_assert(typ, "Link can't be resolved: "..str)

		if typ == "this" then
			typ = this_entity.entity_type
			group_id = this_entity.group_id
			entity_id = this_entity.entity_id
		end

		return Link:new(typ, group_id, entity_id, field)
	end,

	from_entity = function (entity)
		trace_assert(entity.entity_type and entity.group_id,
			"linker: entity has insufficient data", entity)
		return Link:new(entity.entity_type, entity.group_id, entity.entity_id)
	end,

	is_link = function (str)
		if not type(str) == "string" then return end
		return string.find(str, "^%$.*%$$")
	end,

	get_linked_entity = function (self, entities)
		for _, entity in pairs(entities) do
			if self:is_pointed_to(entity) then
				return entity
			end
		end
	end,

	resolve = function (self, entities)
		local entity = self:get_linked_entity(entities)
		local out = self:resolve_field(entity)
		return out and tostring(out) or nil
	end,

	resolve_field = function (self, entity)
		return entity[self.field]
	end,

	is_pointed_to = function (self, entity)
		return (self.type == entity.entity_type) and
			(self.group_id == entity.group_id) and
			(self.entity_id == (entity.entity_id or 1))
	end,
}

function has_dependency(str)
    return string.find(str, "%b$$")
end

function dependency_iterator(str)
	return str:gmatch("%b$$")
end

function resolve_dependencies(str, entity)
	for dep in dependency_iterator(str) do
		local link = Link.from(dep, entity)
		if link:is_pointed_to(entity) then
			str = str:gsub(igi_utils.escape_pattern(dep), link:resolve_field(entity))
		end
	end
	return str
end
