function get_player_tier()
	local player_rank = db.actor:character_rank()
	local tiers = igi_db.SectionView.new("tiers.ltx", "player_tiers")
	for tier, bounds in pairs(tiers:as_table()) do
		if player_rank >= bounds[1] and player_rank <= bounds[2] then
			return tier
		end
	end
	return "endgame"
end

function scale_value(str)
	local player_tier = igi_helper.get_player_tier()
	return string.gsub(str, "scalable", player_tier)
end

------------------------------------------------
local function check_smarts(smarts_table, --[[optional]] nearby_req, --[[optional]] online_req)
	-- This function checks table of smarts for
	-->	- availability
	-->	- smart is not a base
	--> - smart is not in blacklisted_maps
	--> - (optional) online and on level of player (nearby)
	-- and returns a table of suitable smarts
	assert(type(smarts_table) == 'table', 'Igi: check_smarts: not a table given')
	local return_list = {}
	local blacklisted_maps = igi_db.SectionView.new("blacklist.ltx", "maps"):as_set()
	
	for smart_name, smart_data in pairs(smarts_table) do
		if simulation_objects.available_by_id[smart_data.id] and	-- availability check
				not simulation_objects.base_smarts[smart_name] then	-- base smart check
			local smart_level = alife():level_name(game_graph():vertex(smart_data.m_game_vertex_id):level_id())
			
			
			if not blacklisted_maps[smart_level] and not smart_data.squads then						-- blacklist check
				local is_online = smart_data.online
				local is_nearby = string.find(simulation_objects.config:r_value(level.name(), "target_maps", 0, ""), smart_level)
				
				if (nearby_req == nil and online_req == nil) or		-- any OR
						((nearby_req and online_req) and (is_online or is_nearby)) or	-- nearby + online OR
						(not is_nearby == not nearby_req) and 		-- specified
						(not is_online == not online_req) then		-- not is used to convert to boolean
					return_list[#return_list + 1] = smart_name
				end
			end
		end
	end
	return return_list
end

local function get_faction_enemies(faction, --[[optional]] monolith_included)
	monolith_included = monolith_included or false
	local enemies_set = {}
	factions = igi_db.SectionView.new('squad_base.ltx', 'guard')
	
	for enemy_faction in pairs(factions:as_table()) do
		if (game_relations.is_factions_enemies(faction, enemy_faction)) then
			if (enemy_faction ~= "monolith" or monolith_included) then
				enemies_set[enemy_faction] = true
			end
		end
	end
	return enemies_set
end

local function get_faction_setup()	-- TODO: implement factions
	-- This function returns target character factions for all possible quests
	-- Quest by himself decides, which character(s) to use
	
	local faction_list = {
		["actor"] = 'stalker',		-- default values is 'stalker', will be changed if possible
		["task_giver"] = 'stalker',
		["client"] = 'stalker',
		["enemy"] = 'stalker',
	}
	
	local task_giver = mob_trade.GetTalkingNpc()
	faction_list.task_giver = character_community(task_giver)
	faction_list.actor = character_community(db.actor)
	
	local player_enemies = get_faction_enemies(faction_list.actor)
	local task_giver_enemies = get_faction_enemies(faction_list.task_giver)
	
	-- set enemy - must be enemy for both player and task giver
	tmp_enemies = {}	
	for faction in pairs(player_enemies) do					-- search for enemies of both player and task giver
		if task_giver_enemies[faction] then
			tmp_enemies[#tmp_enemies + 1] = faction
		end
	end
	if (#tmp_enemies == 0) then printf("GhenTuong: player and task giver doesn't share enemies") end
	faction_list["enemy"] = tmp_enemies[math.random(#tmp_enemies)] or "stalker"
	
	-- set client - must be enemy for enemy and not enemy with task giver; can be player's faction
	local enemy_enemies = get_faction_enemies(faction_list["enemy"])
	tmp_enemies = {}
	for faction in pairs(enemy_enemies) do
		if(faction ~= faction_list["task_giver"] and task_giver_enemies[faction] == nil) then
			tmp_enemies[#tmp_enemies + 1] = faction
		end
	end
	if (#tmp_enemies == 0) then printf("GhenTuong: can't setup client") end
	faction_list["client"] = tmp_enemies[math.random(#tmp_enemies)] or "stalker"
	return faction_list
end

local function pick_quest_goods(quest_type)
	if not quest_type then return end

	local possible_goods = igi_db.SectionView.new("quest_goods.ltx", quest_type)
	local goods_type = possible_goods:random()
	return goods_type
end

local function create_DescriptionData(faction, target, location)
	local tbl = {
		_cls = "DescriptionData",
		factions = faction,
		targets = target,
		locations = location,
	}
	return tbl
end

local function create_SquadsData(ids, name, faction, location)
	local tbl = {
		_cls = "EntityData",
		typ = "squad",
		ids = ids,
		name = name,
		faction = faction,
		location = location,
	}
	return tbl
end

local function create_SmartData(names)
	local tbl = {
		_cls = "EntityData",
		names = names,
	}
	return tbl
end

local function create_GroupData(entity_data, target, amount)
	assert(entity_data._cls == "EntityData", "Igi: setup: entity_data in not EntityData")

	local default_target = igi_db.SectionView.new("defaults.ltx", "default_target")
	
	entity_data.target = target or default_target[entity_data.typ]
	entity_data.amount = amount or 1

	return entity_data
end

local function create_PackageData(sec_name, location)
	local tbl = {
		_cls = "EntityData",
		typ = "package",
		section_name = sec_name,
		location = location,
	}
	return tbl
end

local function create_ItemData(ids)
	local tbl = {
		_cls = "EntityData",
		ids = ids,
	}
	return tbl
end

local function create_squad_data(squad_info, factions)
	-- important: location, name, faction, description, target, amount
	local squad_name, squad_type, faction
	local squads = assert(igi_db.SectionView.new("squad_base.ltx", squad_info.type),
		"Igi: setup squad: Unknown squad type")
	if string.find(squad_info.type, "mutant") then
		squad_name, squad_type = squads:random()
	else
		assert(squad_info.faction or squad_info.faction_type, "Igi: setup_squad: No faction data")
		faction = squad_info[squad_info.faction] or factions[squad_info.faction_type]
		squad_name = squads[faction]
	end
	
	assert(squad_name, "Igi: setup_squad: Unable to set squad_name")
	-- set all default
	local squad_data = create_SquadsData(nil, squad_name, faction or "mutant", squad_info.where)
	local target_desc = squad_type and igi_db.TEXT_HEADER .. squad_type or nil
	local description = create_DescriptionData(faction, target_desc, squad_data.location)

	return squad_data, description
end

local function fetch_squad_data(squad_info, factions)
	-- important: ids, predefined name, description, target
	local finder = igi_finder.get_finder()
	local factions
	if squad_info.type == "mutant" then
		factions = igi_db.SectionView.new(
				"finder\\squad_types.ltx", "monster_types"
				):as_set()
	else
		factions = get_faction_enemies(factions.actor)
	end
	local squads = finder:get_squads_by_args(squad_info, factions)
	local ids = igi_utils.get_random_items(squads, squad_info.amount or 1)
	if not ids then return end

	local location_desc = {}
	local comm_desc = {}
	for _, id in pairs(ids) do
		local se_obj = igi_helper.alife_obj(id)
		local community = game.translate_string(se_obj.player_id)
		comm_desc[#comm_desc+1] = community
		location_desc[#location_desc+1] = dynamic_news_helper.GetPointDescription(se_obj)
	end

	local squad_data = create_SquadsData(ids, "predefined_squad")
	local description = create_DescriptionData(nil, comm_desc, location_desc)
	return squad_data, description
end

local function fetch_item_description(objects, item_type)
	local factions = {}
	local targets = {}
	local locations = {}
	
	for _, se_obj in pairs(objects) do
		local parent_id = se_obj.parent_id
		local parent_npc = igi_helper.check_common_npc(parent_id) and igi_helper.alife_obj(parent_id)
		local desc_target = igi_db.TEXT_HEADER..string.match(item_type, "^(%a+)")
		
		factions[#factions+1] = parent_npc and igi_helper.get_community(parent_npc) or nil
		targets[#targets+1] = parent_npc and parent_npc:character_name() or desc_target
		locations[#locations+1] = igi_helper.get_object_location_description(se_obj)
	end
	return create_DescriptionData(factions, targets, locations)
end

local function find_objects(object_data, amount)
	local finder = igi_finder.get_finder()
	objects = finder:get_objects_by_args(
		igi_helper.scale_value(object_data.item_type), 
		object_data, 
		object_data.possible_endings, 
		object_data.only_endings)

	if not next(objects) then 
		printf("Igi: no objects")
		return nil 
	end

	return igi_utils.get_random_items(objects, object_data.amount or 1)
end

local function fetch_item_data(item_info, factions)
	item_info.enemy_to = factions[item_info.enemy_to] or item_info.enemy_to

	local objects = find_objects(item_info, item_info.amount or 1)
	if not objects then return nil end
	
	local ids = {}
	for _, se_obj in pairs(objects) do
		ids[#ids + 1] = se_obj.id
	end

	local item_data = create_ItemData(ids)
	local description = fetch_item_description(objects, item_info.item_type)
	local group_data = create_GroupData(
		item_data,
		item_info.target,
		item_info.amount
	)
	return group_data, description
end

local function add_predefined_values(group_data, entity_preset)
	group_data.entity_type = entity_preset.entity_type
	group_data.group_id = entity_preset.group_id
	group_data.online_activities = entity_preset.online_activities
end
------------------------------------------------
local function init_constructor(task_name)
	local constructor = {}
	local tbl = igi_db.get_task_data(task_name)
	copy_table(constructor, tbl)
	constructor = igi_helper.scale_to_rank(constructor)
	constructor = igi_linker.assign_group_id(constructor)
	return constructor
end

local function setup_squad(squad_info, factions)
	local squad_data, description
	if squad_info.to_create then
		squad_data, description = create_squad_data(squad_info, factions)
	else
		squad_data, description = fetch_squad_data(squad_info, factions)
		if not squad_data then return end
	end
	
	local group_data = create_GroupData(	-- set defaults
		squad_data, 
		squad_info.target,
		squad_info.amount
	)
	return group_data, description
end

local function setup_smart(smart_data)
	local amount = smart_data.amount or 1;

	local finder = igi_finder.get_finder()
	local possible_smarts = finder:get_smarts(smart_data.where)
	
	if #possible_smarts < amount then 
		printf("smarts sucked")
		return nil 
	end
	local smarts_list = igi_utils.get_random_items(possible_smarts, amount)
	local smart_names = {}
	for _, smart_data in pairs(smarts_list) do
		table.insert(smart_names, smart_data.smrt:name())
	end

	local group_data = create_GroupData(
		create_SmartData(smart_names),
		smart_data.target,
		smart_data.amount
	)
	--printf("SMART END")
	return group_data
end

local function setup_package(pkg_info, factions)
	--printf("PACKAGE START")
	local pkg_type = pkg_info.package_type or pick_quest_goods(pkg_info.quest_type)
	
	if not pkg_type then
		printf("Igi: setup_package: No package type given")
		return nil
	end

	local section_name = "igi_package_"..pkg_type
	local amount = pkg_info.amount or ini_sys:r_float_ex(section_name, "default_amount_package")
	
	local pkg_data = create_PackageData(section_name, pkg_info.where)
	local desc = create_DescriptionData(nil, igi_db.TEXT_HEADER..pkg_type)
	
	local group_data = create_GroupData(
		pkg_data,
		pkg_info.target,
		amount
	)
	--printf("PACKAGE END")
	return group_data, desc
end

local function setup_item(item_data, factions)
	assert(item_data.item_type, "Igi: setup_item: No item list given")

	local group_data, description
	if item_data.to_create then
		printf("TODO")		-- TODO
	else
		group_data, description = fetch_item_data(item_data, factions)
		if not group_data then return end
	end
	return group_data, description
end

function setup_quest(task_name)
	local constructor = init_constructor(task_name)
	CACHE = {["setup"] = {},}
	CACHE.task_name = task_name
	CACHE.factions = get_faction_setup()
	local description = igi_description.TaskDescription.new()
	
	local handlers = {
		["squad"] = setup_squad,
		["package"] = setup_package,
		["item"] = setup_item,
		["smart"] = setup_smart,
	}
	
	for _, entity_preset in pairs(constructor) do
		assert(handlers[entity_preset.entity_type], "Unknown entity_preset type: "..entity_preset.entity_type)
		local group_data, desc = handlers[entity_preset.entity_type](entity_preset, CACHE.factions)
		if not group_data then return nil end
		
		add_predefined_values(group_data, entity_preset)
		description:add_entries(desc)

		local group_link = igi_linker.make_link(entity_preset.entity_type, entity_preset.group_id)
		CACHE.setup[group_link] = group_data
	end
	CACHE.description = description:get_description(CACHE)
	return CACHE
end


