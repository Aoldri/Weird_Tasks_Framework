local trace_dbg = igi_helper.trace_dbg
local trace_assert = igi_helper.trace_assert

-------------------------------------------------
-- task table reworking functions
-------------------------------------------------
local function wrap_array_keys(task_table)
	local array_keys = {"where", "look_in"}

	for _, entity in pairs(task_table) do
		for _, k in pairs(array_keys) do

			local val = entity[k]
			if type(val) == "string" and not igi_linker.is_dependency(val) then
				entity[k] = {entity[k]}
			end
		end
	end
end

local function create_smart_and_redirect(entity, counter, smarts_table)
	local smart = igi_models.create_smart_setup(entity.where or {"everywhere"})
	table.insert(smarts_table, smart)

	counter["smart"] = counter["smart"] + 1
	entity.where = "$smart_"..tostring(counter["smart"]).."_1$"
end

local function count_entities(task_setup)
	local counter = {
		smart = 0,
		squad = 0,
		item = 0,
	}
	for _, v in pairs(task_setup) do
		counter[v.entity_type] = counter[v.entity_type] + 1
	end
	return counter
end

local function setup_task_locations(task_table, counter)
	local new_smarts = {}
	
	for _, entity in pairs(task_table) do
		if entity.to_create and type(entity.where) ~= "string" then
			create_smart_and_redirect(entity, counter, new_smarts)
		end
	end
	
	igi_utils.extend_list(task_table, new_smarts)
end

-------------------------------------------------
-- JSON functions
-------------------------------------------------
local function get_game_path()
  local info = debug.getinfo(1,'S');
  local script_path = info.source:match[[^@?(.*[\/])[^\/]-$]]
  local game_path = script_path:match("(.*)gamedata"):gsub("/", "\\")
  return game_path
end

local default_tasks_path = get_game_path().."gamedata\\configs\\igi_tasks\\tasks\\"
local configured_tasks_path = get_game_path().."igi_tasks\\tasks\\"
local function read_task_json(task_name, prefix)
	local task_path = prefix.."\\"..task_name..".json"

	local file = trace_assert(io.open(configured_tasks_path..task_path, "rb"))
	if not file then
		file = trace_assert(io.open(default_tasks_path..task_path, "rb"))
	end

    if not file then return end

    local content = file:read "*a" -- *a or *all reads the whole file
	trace_dbg("json content: ", content)
    file:close()
    return content
end

local json = igi_json.get_json()
function get_task_table(task_name, prefix)
	local task_json = trace_assert(
		read_task_json(task_name, prefix),
		"task_json: no json file for task "..prefix.."_"..task_name
	)
	if not task_json then return end
	return json.decode(task_json)
end

local function save_file(path, content)
	local file = trace_assert(io.open(path, "w"))
	if not file then
		os.execute('echo 1 > '..path)
		file = trace_assert(io.open(path, "w"))
	end
	file:write(content)
	file:close()
end

local function create_path(prefix)
	local tasks_path = '"'..get_game_path().."igi_tasks\\"..'"'
	os.execute(
		"mkdir "..tasks_path.." & "..
		"mkdir "..tasks_path.."tasks\\".." & "..
		"mkdir "..tasks_path.."tasks\\"..prefix
	)
end
create_path = igi_utils.one_timer_one_variable(create_path, "ot_create_path")

local function save_task_table(task_name, prefix, table)
	create_path(prefix)
	local task_path = prefix.."\\"..task_name..".json"
	local path = configured_tasks_path..task_path
	local content = json.encode(table)
	trace_dbg("save", path, content)
	save_file(path, content)
end

function update_task_table_value(task_name, prefix, key, value)
	local new_tbl = dup_table(get_task_table(task_name, prefix))
	new_tbl[key] = value
	save_task_table(task_name, prefix, new_tbl)
	igi_utils.MemoizeCache.reset("task_data")
end

-------------------------------------------------
-- global functions
-------------------------------------------------
function get_task_data(task_id)
	local prefix, task_name = igi_helper.get_task_name(task_id)
	trace_dbg("get_task_data: ", prefix, task_name)
	local task_tbl = get_task_table(task_name, prefix)
	assert(task_tbl, "Igi: no such task: "..tostring(task_id or "nil"))

	wrap_array_keys(task_tbl.setup)
	task_tbl.group_counter = count_entities(task_tbl.setup)
	setup_task_locations(task_tbl.setup, task_tbl.group_counter)
	igi_callbacks.invoke_target_callbacks("on_get_taskdata", task_tbl.setup, task_tbl.setup)
	return task_tbl
end
get_task_data = igi_utils.memoize_one_variable(get_task_data, "task_data")

function get_task_setup(task_id)
	return get_task_data(task_id).setup
end

function get_finalized_task_setup(task_id)
	local tbl = get_task_data(task_id)
	local task_setup = dup_table(tbl.setup)

	task_setup = igi_linker.assign_group_id(task_setup)
	task_setup = igi_text_processor.resolve_unlinked_macros(task_setup)
	igi_text_processor.link_virtual_variables(task_setup)
	return task_setup
end

function get_target_table(target)
	if not target then return end
	local target_tbl = _G["igi_target_"..target]

	if not target_tbl then
		callstack()
		assert(nil, "Igi Tasks: no target tbl for target "..tostring(target or "nil"))
	end

	if target_tbl.PATTERN then
		setmetatable(target_tbl, {__index = get_target_table(target_tbl.PATTERN)})
	end
	return target_tbl
end
get_target_table = igi_utils.memoize_one_variable(get_target_table, "target_table")
