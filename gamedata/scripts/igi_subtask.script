
local function get_continuous_functors(subtask_name)
	if not subtask_name then return end

	local continuous_objective = {
		["return"] = {
			is_not_failed = igi_helper.object_exist,
			on_complete = igi_helper.deliver_item,
			ready_to_finish = igi_helper.object_in_player_inventory
		},
	}
	return continuous_objective[subtask_name]
end

local function get_instant_functors(subtask_name)
	if not subtask_name then return end

	local instant_objective = {
		["kill"] = {is_complete = igi_helper.object_not_exist},
		["get"] = {is_complete = igi_helper.object_in_player_inv},
	}
	return instant_objective[subtask_name]
end

function process_instant_subtasks(subtasks)
	-- Instant = instant without completed tasks
	for k, subtask_data in pairs(subtasks.instant) do
		local complete_functor = get_instant_functors(subtask_data.target).is_complete
		assert(complete_functor, "Igi: no complete functor for "..subtask_data.target)
		if complete_functor(subtask_data) then
			subtasks.instant[k] = nil
			return
		end
		-- Check if object still exists
		local se_obj = igi_helper.alife_obj(subtask_data.id)
		if not se_obj then return "fail" end
		if se_obj:section_name() ~= subtask_data.section_name then return "fail" end
	end
end

function check_continuous_failed(subtasks_continuous)
	-- Returns false, if at least one condition is failed;
	-- Continuous objectives will be completed with task end and can be failed

	-- If functor of continuous not true - mission fail
	for k, subtask_data in pairs(subtasks_continuous) do
		local functor = get_continuous_functors(subtask_data.target).is_not_failed
		if not functor(subtask_data) then
			return true
		end
		
		local se_obj = igi_helper.alife_obj(subtask_data.id)
		if not se_obj then return true end
		if se_obj:section_name() ~= subtask_data.section_name then return true end
	end
	return false
end

function check_continuous_running(subtasks_continuous)
	for k, subtask_data in pairs(subtasks_continuous) do
		local functor = get_continuous_functors(subtask_data.target).ready_to_finish
		if not functor(subtask_data) then
			return true
		end
	end
	return false
end

function finish_continuous_subtasks(subtasks_continuous, is_complete)
	for _, subtask_data in pairs(subtasks_continuous) do
		local complete_functor = get_continuous_functors(subtask_data.target).on_complete
		local fail_functor = get_continuous_functors(subtask_data.target).on_fail
		-- printf("Igi: subtask finish: "..subtask_data.section_name..tostring(subtask_data.id))
		if is_complete then complete_functor(subtask_data)
		elseif not is_complete and fail_functor then
			fail_functor(subtask_data)
		end
	end
	--printf("Igi: finish end")
end
---------------------------------------------------
function quest_target(subtasks)
	if not subtasks or not (subtasks.instant and subtasks.continuous) then
		return 
	end

	_, target_obj = next(subtasks.instant)
	if not target_obj then
		for _, subtask_data in pairs(subtasks.continuous) do
			local is_ready = get_continuous_functors(subtask_data.target).ready_to_finish
			target_obj = not is_ready(subtask_data) and subtask_data
			if target_obj then break end
		end
	end
	return target_obj and target_obj.id
end
---------------------------------------------------
function setup_subtask(targets)
	local subtasks = {
		instant = {},
		continuous = {},
	}
	for id, entity in pairs(targets) do
		table.insert(subtasks.instant, get_instant_functors(entity.target) and entity or nil)
		table.insert(subtasks.continuous, get_continuous_functors(entity.target) and entity or nil)
	end

	return subtasks
end
---------------------------------------------------
local function update_mark(obj_data, mark_type)
	--printdbg("Igi: Spot in world: "..tostring(igi_helper.object_in_world(obj_data.se_obj)).." spot: "..tostring(level.map_has_object_spot(obj_data.id, mark_type)))
	if igi_helper.object_in_world(igi_helper.alife_obj(obj_data.id)) then
		if level.map_has_object_spot(obj_data.id, mark_type) == 0 then
			level.map_add_object_spot(obj_data.id, mark_type, game.translate_string(igi_db.TEXT_HEADER .. mark_type))
		end
	else
		if level.map_has_object_spot(obj_data.id, mark_type) == 1 then
			level.map_remove_object_spot(obj_data.id, mark_type)
		end
	end
end

function update_marks(entities)
	local marks = {
		["package"] = "treasure_unique",
		["item"] = "item_misc",
	}
	
	for entity_name, entity in pairs(entities) do
		local mark = marks[string.match(entity_name, "%$(%D+)_")]
		if mark then
			update_mark(entity, mark)
		end
	end
end

function unmark_all(entities)
	local marks = {
		["package"] = "treasure_unique",
		["item"] = "item_misc",
	}
	
	for entity_name, entity in pairs(entities) do
		local mark = marks[string.match(entity_name, "%$(%D+)_")]
		if mark then
			level.map_remove_object_spot(entity.id, mark)
		end
	end
end
