local trace_assert = igi_helper.trace_assert
local trace_dbg = igi_helper.trace_dbg

function on_game_start()
	RegisterScriptCallback("actor_on_first_update", actor_on_first_update)
end

function actor_on_first_update()
	igi_models.add_interface_implementation("Entity", Entity)
	igi_models.add_interface_implementation("EntitiesTable", EntitiesTable)
	igi_models.add_interface_implementation("Cache", Cache)
end

TASK_STATUSES = {
	RUNNING = "RUNNING",
	COMPLETED = "COMPLETED",
	FAILED = "FAILED",
	READY_TO_FINISH = "READY_TO_FINISH",
	DISABLED = "DISABLED",
	CANCELLED = "CANCELLED",
}

Cache = {
	update_current_map_target = function (self)
		self.current_target_id = self:quest_target()
	end,

	set_map_target_to_task_giver = function (self)
		self.current_target_id = self.task_giver_id
	end,

	get_current_target_id = function (self)
		return self.current_target_id
	end,

	quest_target = function (self)
		return self:get_entities():quest_target()
	end,

	_update_status = function (self)
		self.status = self:get_entities():get_task_status()
	end,

	initialise_subtasks = function (self)
		self.status = TASK_STATUSES.RUNNING
		self:get_entities():initialise_subtasks()
	end,

	process_subtasks = function (self)
		local updated = self:get_entities():process_subtasks()
		if updated then self:_update_status() end
		return updated
	end,

	finish_all_subtasks = function (self)
		if self.status ~= TASK_STATUSES.FAILED then
			self.status = TASK_STATUSES.COMPLETED
		else
			self.status = TASK_STATUSES.FAILED
		end

		self:get_entities():change_subtasks_status(
			TASK_STATUSES.READY_TO_FINISH,
			self.status
		)
	end,

	is_task_failed = function (self)
		return self.status == TASK_STATUSES.FAILED
	end,

	is_task_completed = function (self)
		return self.status == TASK_STATUSES.COMPLETED
	end,

	is_time_to_return = function (self)
		return self.status ~= TASK_STATUSES.RUNNING
	end,
}

EntitiesTable = {
	_default_subtask_order = 0,

	initialise_subtasks = function (self)
		for _, entity in pairs(self) do
			if entity.target then
				entity:set_status(TASK_STATUSES.RUNNING)
			end
		end
	end,

	process_subtasks = function (self)
		local updated = false
		for _, entity in pairs(self) do
			if entity:is_active_subtask() and entity:update_status() then
				updated = true
			end
		end
		return updated
	end,

	change_subtasks_status = function (self, old_status, new_status)
		trace_assert(TASK_STATUSES[old_status] and TASK_STATUSES[new_status], 'Unknown task status')
		for _, entity in pairs(self) do
			if entity:get_status() == old_status then
				entity:set_status(new_status)
			end
		end
	end,

	quest_target = function (self)
		local min_order = 100000
		local target_id
		for _, entity in pairs(self) do
			if entity.target
				and entity:get_status() == TASK_STATUSES.RUNNING
				and (entity.order or 1) < min_order then

				local target_tbl = entity:get_target_table()
				local target = target_tbl.quest_target(entity)
				if target then
					min_order = entity.order or 1
					target_id = target
				end
			end
		end

		return target_id
	end,

	get_task_status = function (self)
		local ready_to_finish = false
		local running = false
		for _, entity in pairs(self) do
			if entity.target and entity:is_subtask_failed() then
				return TASK_STATUSES.FAILED
			end

			local status = entity.target and entity:get_status()
			if status == TASK_STATUSES.RUNNING then
				running = true
			elseif status == TASK_STATUSES.READY_TO_FINISH then
				ready_to_finish = true
			end
		end

		if running then return TASK_STATUSES.RUNNING
		elseif ready_to_finish then return TASK_STATUSES.READY_TO_FINISH
		else return TASK_STATUSES.COMPLETED end
	end,
}

Entity = {
	is_subtask = function (self)
		return self.target and true
	end,

	get_target = function (self)
		return self.target
	end,

	set_target = function (self, target)
		trace_assert(igi_taskdata.get_target_table(target), "Target unknown: "..target)
		self.target = target
		self.status = TASK_STATUSES.RUNNING
	end,

	get_status = function (self)
		return self.status
	end,

	set_status = function (self, status)
		trace_assert(TASK_STATUSES[status], 'Unknown task status')
		self.status = status
	end,

	update_status = function (self)
		local new_status = self:get_target_table().get_status(self)
		if new_status == self:get_status() then return end
		self:set_status(new_status)
		igi_callbacks.invoke_callbacks("on_subtask_status_change", self)
		return true
	end,

	is_optional = function (self)
		return self.optional
	end,

	is_subtask_failed = function (self)
		return self:get_status() == TASK_STATUSES.FAILED
			and not self:is_optional()
	end,

	set_order = function (self, order)
		trace_assert(type(order) == "number", "Order is not a number")
		self.order = order
	end,

	is_active_subtask = function (self)
		if not self.target then return end
		local status = self:get_status()
		return status == TASK_STATUSES.RUNNING or
			status == TASK_STATUSES.READY_TO_FINISH
	end,
}
